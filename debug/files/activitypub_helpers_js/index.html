<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - activitypub/helpers.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>activitypub/helpers.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">61.48</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">520</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">58.04</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">5.87</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;

const { generateKeyPairSync } = require(&#039;crypto&#039;);
const process = require(&#039;process&#039;);
const nconf = require(&#039;nconf&#039;);
const winston = require(&#039;winston&#039;);
const validator = require(&#039;validator&#039;);
// const cheerio = require(&#039;cheerio&#039;);
const crypto = require(&#039;crypto&#039;);

const meta = require(&#039;../meta&#039;);
const posts = require(&#039;../posts&#039;);
const categories = require(&#039;../categories&#039;);
const messaging = require(&#039;../messaging&#039;);
const request = require(&#039;../request&#039;);
const db = require(&#039;../database&#039;);
const ttl = require(&#039;../cache/ttl&#039;);
const user = require(&#039;../user&#039;);
const utils = require(&#039;../utils&#039;);
const activitypub = require(&#039;.&#039;);

const webfingerRegex = /^(@|acct:)?[\w-.]+@.+$/;
const webfingerCache = ttl({
	max: 5000,
	ttl: 1000 * 60 * 60 * 24, // 24 hours
});
const sha256 = payload =&gt; crypto.createHash(&#039;sha256&#039;).update(payload).digest(&#039;hex&#039;);

const Helpers = module.exports;

Helpers._webfingerCache = webfingerCache; // exported for tests

Helpers._test = (method, args) =&gt; {
	// because I am lazy and I probably wrote some variant of this below code 1000 times already
	setTimeout(async () =&gt; {
		console.log(await method.apply(method, args));
	}, 2500);
};
// process.nextTick(() =&gt; {
// Helpers._test(activitypub.notes.assert, [1, `https://`]);
// });
let _lastLog;
Helpers.log = (message) =&gt; {
	if (!message) {
		return _lastLog;
	}

	_lastLog = message;
	if (process.env.NODE_ENV === &#039;development&#039;) {
		winston.verbose(message);
	}
};

Helpers.isUri = (value) =&gt; {
	if (typeof value !== &#039;string&#039;) {
		value = String(value);
	}

	return validator.isURL(value, {
		require_protocol: true,
		require_host: true,
		protocols: activitypub._constants.acceptedProtocols,
		require_valid_protocol: true,
		require_tld: false, // temporary â€” for localhost
	});
};

Helpers.assertAccept = accept =&gt; (accept &amp;&amp; accept.split(&#039;,&#039;).some((value) =&gt; {
	const parts = value.split(&#039;;&#039;).map(v =&gt; v.trim());
	return activitypub._constants.acceptableTypes.includes(value || parts[0]);
}));

Helpers.isWebfinger = (value) =&gt; {
	// N.B. returns normalized handle, so truthy check!
	if (webfingerRegex.test(value) &amp;&amp; !Helpers.isUri(value)) {
		if (value.startsWith(&#039;@&#039;)) {
			return value.slice(1);
		} else if (value.startsWith(&#039;acct:&#039;)) {
			return value.slice(5);
		}

		return value;
	}

	return false;
};

Helpers.query = async (id) =&gt; {
	const isUri = Helpers.isUri(id);
	// username@host ids use acct: URI schema
	const uri = isUri ? new URL(id) : new URL(`acct:${id}`);
	// JS doesn&#039;t parse anything other than protocol and pathname from acct: URIs, so we need to just split id manually
	let [username, hostname] = isUri ? [uri.pathname || uri.href, uri.host] : id.split(&#039;@&#039;);
	if (!username || !hostname) {
		return false;
	}
	username = username.trim();
	hostname = hostname.trim();

	const cached = webfingerCache.get(id);
	if (cached !== undefined) {
		return cached;
	}

	const query = new URLSearchParams({ resource: uri });

	// Make a webfinger query to retrieve routing information
	let response;
	let body;
	try {
		({ response, body } = await request.get(`https://${hostname}/.well-known/webfinger?${query}`, {
			headers: {
				accept: &#039;application/jrd+json&#039;,
			},
		}));
	} catch (e) {
		return false;
	}

	if (response.statusCode !== 200 || !body.hasOwnProperty(&#039;links&#039;)) {
		return false;
	}

	// Parse links to find actor endpoint
	let actorUri = body.links.filter(link =&gt; activitypub._constants.acceptableTypes.includes(link.type) &amp;&amp; link.rel === &#039;self&#039;);
	if (actorUri.length) {
		actorUri = actorUri.pop();
		({ href: actorUri } = actorUri);
	}

	const { subject, publicKey } = body;
	const payload = { subject, username, hostname, actorUri, publicKey };

	const claimedId = new URL(subject).pathname;
	webfingerCache.set(claimedId, payload);
	if (claimedId !== id) {
		webfingerCache.set(id, payload);
	}

	return payload;
};

Helpers.generateKeys = async (type, id) =&gt; {
	activitypub.helpers.log(`[activitypub] Generating RSA key-pair for ${type} ${id}`);
	const {
		publicKey,
		privateKey,
	} = generateKeyPairSync(&#039;rsa&#039;, {
		modulusLength: 2048,
		publicKeyEncoding: {
			type: &#039;spki&#039;,
			format: &#039;pem&#039;,
		},
		privateKeyEncoding: {
			type: &#039;pkcs8&#039;,
			format: &#039;pem&#039;,
		},
	});

	await db.setObject(`${type}:${id}:keys`, { publicKey, privateKey });
	return { publicKey, privateKey };
};

Helpers.resolveLocalId = async (input) =&gt; {
	if (Helpers.isUri(input)) {
		const { host, pathname, hash } = new URL(input);

		if (host === nconf.get(&#039;url_parsed&#039;).host) {
			const [prefix, value] = pathname.replace(nconf.get(&#039;relative_path&#039;), &#039;&#039;).split(&#039;/&#039;).filter(Boolean);

			let activityData = {};
			if (hash.startsWith(&#039;#activity&#039;)) {
				const [, activity, data, timestamp] = hash.split(&#039;/&#039;, 4);
				activityData = { activity, data, timestamp };
			}

			switch (prefix) {
				case &#039;uid&#039;:
					return { type: &#039;user&#039;, id: value, ...activityData };

				case &#039;post&#039;:
					return { type: &#039;post&#039;, id: value, ...activityData };

				case &#039;cid&#039;:
				case &#039;category&#039;:
					return { type: &#039;category&#039;, id: value, ...activityData };

				case &#039;user&#039;: {
					const uid = await user.getUidByUserslug(value);
					return { type: &#039;user&#039;, id: uid, ...activityData };
				}

				case &#039;message&#039;:
					return { type: &#039;message&#039;, id: value, ...activityData };
			}

			return { type: null, id: null, ...activityData };
		}

		return { type: null, id: null };
	} else if (String(input).indexOf(&#039;@&#039;) !== -1) { // Webfinger
		input = decodeURIComponent(input);
		const [slug] = input.replace(/^(acct:|@)/, &#039;&#039;).split(&#039;@&#039;);
		const uid = await user.getUidByUserslug(slug);
		return { type: &#039;user&#039;, id: uid };
	}

	return { type: null, id: null };
};

Helpers.resolveActor = (type, id) =&gt; {
	switch (type) {
		case &#039;user&#039;:
		case &#039;uid&#039;: {
			return `${nconf.get(&#039;url&#039;)}${id &gt; 0 ? `/uid/${id}` : &#039;/actor&#039;}`;
		}

		case &#039;category&#039;:
		case &#039;cid&#039;: {
			return `${nconf.get(&#039;url&#039;)}/category/${id}`;
		}

		default:
			throw new Error(&#039;[[error:activitypub.invalid-id]]&#039;);
	}
};

Helpers.resolveActivity = async (activity, data, id, resolved) =&gt; {
	switch (activity.toLowerCase()) {
		case &#039;follow&#039;: {
			const actor = await Helpers.resolveActor(resolved.type, resolved.id);
			const { actorUri: targetUri } = await Helpers.query(data);
			return {
				&#039;@context&#039;: &#039;https://www.w3.org/ns/activitystreams&#039;,
				actor,
				id,
				type: &#039;Follow&#039;,
				object: targetUri,
			};
		}
		case &#039;announce&#039;:
		case &#039;create&#039;: {
			const object = await Helpers.resolveObjects(resolved.id);
			// local create activities are assumed to come from the user who created the underlying object
			const actor = object.attributedTo || object.actor;
			return {
				&#039;@context&#039;: &#039;https://www.w3.org/ns/activitystreams&#039;,
				actor,
				id,
				type: &#039;Create&#039;,
				object,
			};
		}
		default: {
			throw new Error(&#039;[[error:activitypub.not-implemented]]&#039;);
		}
	}
};

Helpers.mapToLocalType = (type) =&gt; {
	if (type === &#039;Person&#039;) {
		return &#039;user&#039;;
	}
	if (type === &#039;Group&#039;) {
		return &#039;category&#039;;
	}
	if (type === &#039;Hashtag&#039;) {
		return &#039;tag&#039;;
	}
	if (activitypub._constants.acceptedPostTypes.includes(type)) {
		return &#039;post&#039;;
	}
};

Helpers.resolveObjects = async (ids) =&gt; {
	if (!Array.isArray(ids)) {
		ids = [ids];
	}
	const objects = await Promise.all(ids.map(async (id) =&gt; {
		// try to get a local ID first
		const { type, id: resolvedId, activity, data: activityData } = await Helpers.resolveLocalId(id);
		// activity data is only resolved for local IDs - so this will be false for remote posts
		if (activity) {
			return Helpers.resolveActivity(activity, activityData, id, { type, id: resolvedId });
		}
		switch (type) {
			case &#039;user&#039;: {
				if (!await user.exists(resolvedId)) {
					throw new Error(&#039;[[error:activitypub.invalid-id]]&#039;);
				}
				return activitypub.mocks.actors.user(resolvedId);
			}

			case &#039;post&#039;: {
				const post = (await posts.getPostSummaryByPids(
					[resolvedId],
					activitypub._constants.uid,
					{
						stripTags: false,
						extraFields: [&#039;edited&#039;],
					}
				)).pop();
				if (!post) {
					throw new Error(&#039;[[error:activitypub.invalid-id]]&#039;);
				}
				return activitypub.mocks.notes.public(post);
			}

			case &#039;category&#039;: {
				if (!await categories.exists(resolvedId)) {
					throw new Error(&#039;[[error:activitypub.invalid-id]]&#039;);
				}
				return activitypub.mocks.actors.category(resolvedId);
			}

			case &#039;message&#039;: {
				if (!await messaging.messageExists(resolvedId)) {
					throw new Error(&#039;[[error:activitypub.invalid-id]]&#039;);
				}
				const messageObj = await messaging.getMessageFields(resolvedId, []);
				messageObj.content = await messaging.parse(messageObj.content, messageObj.fromuid, 0, messageObj.roomId, false);
				return activitypub.mocks.notes.private({ messageObj });
			}

			// if the type is not recognized, assume it&#039;s not a local ID and fetch the object from its origin
			default: {
				return activitypub.get(&#039;uid&#039;, 0, id);
			}
		}
	}));
	return objects.length === 1 ? objects[0] : objects;
};

const titleishTags = [&#039;h1&#039;, &#039;h2&#039;, &#039;h3&#039;, &#039;h4&#039;, &#039;h5&#039;, &#039;h6&#039;, &#039;title&#039;, &#039;p&#039;, &#039;span&#039;];
const titleRegex = new RegExp(`&lt;(${titleishTags.join(&#039;|&#039;)})&gt;(.+?)&lt;/\\1&gt;`, &#039;m&#039;);
Helpers.generateTitle = (html) =&gt; {
	// Given an html string, generates a more appropriate title if possible
	let title;

	// Try the first paragraph-like element
	const match = html.match(titleRegex);
	if (match &amp;&amp; match.index === 0) {
		title = match[2];
	}

	// Fall back to newline splitting (i.e. if no paragraph elements)
	title = title || html.split(&#039;\n&#039;).filter(Boolean).shift();

	// Discard everything after a line break element
	title = title.replace(/&lt;br(\s\/)?&gt;.*/g, &#039;&#039;);

	// Strip html
	title = utils.stripHTMLTags(title);

	// Split sentences and use only first one
	const sentences = title
		.split(/(\.|\?|!)\s/)
		.reduce((memo, cur, idx, sentences) =&gt; {
			if (idx % 2) {
				memo.push(`${sentences[idx - 1]}${cur}`);
			} else if (idx === sentences.length - 1) {
				memo.push(cur);
			}

			return memo;
		}, []);

	if (sentences.length &gt; 1) {
		title = sentences.shift();
	}

	// Truncate down if too long
	if (title.length &gt; meta.config.maximumTitleLength) {
		title = `${title.slice(0, meta.config.maximumTitleLength - 3)}...`;
	}

	return title;
};

Helpers.remoteAnchorToLocalProfile = async (content, isMarkdown = false) =&gt; {
	let anchorRegex;
	if (isMarkdown) {
		anchorRegex = /\[(.*?)\]\((.+?)\)/ig;
	} else {
		anchorRegex = /&lt;a.*?href=[&#039;&quot;](.+?)[&#039;&quot;].*?&gt;(.*?)&lt;\/a&gt;/ig;
	}

	const anchors = content.matchAll(anchorRegex);
	const urls = new Set();
	const matches = [];
	for (const anchor of anchors) {
		let match;
		let url;
		if (isMarkdown) {
			[match,, url] = anchor;
		} else {
			[match, url] = anchor;
		}
		matches.push([match, url]);
		urls.add(url);
	}

	if (!urls.size) {
		return content;
	}

	const urlMap = new Map();
	const urlsArray = Array.from(urls);

	// Local references
	const localUrls = urlsArray.filter(url =&gt; url.startsWith(nconf.get(&#039;url&#039;)));
	await Promise.all(localUrls.map(async (url) =&gt; {
		const { type, id } = await Helpers.resolveLocalId(url);
		if (type === &#039;user&#039;) {
			urlMap.set(url, id);
		} // else if (type === &#039;category&#039;) {
	}));

	// Remote references
	const [backrefs, urlAsIdExists] = await Promise.all([
		db.getObjectFields(&#039;remoteUrl:uid&#039;, urlsArray),
		db.isSortedSetMembers(&#039;usersRemote:lastCrawled&#039;, urlsArray),
	]);
	urlsArray.forEach((url, index) =&gt; {
		if (backrefs[url] || urlAsIdExists[index]) {
			urlMap.set(url, backrefs[url] || url);
		}
	});

	let slugs = await user.getUsersFields(Array.from(urlMap.values()), [&#039;userslug&#039;]);
	slugs = slugs.map(({ userslug }) =&gt; userslug);
	Array.from(urlMap.keys()).forEach((url, idx) =&gt; {
		urlMap.set(url, `/user/${encodeURIComponent(slugs[idx])}`);
	});

	// Modify existing anchors to local profile
	matches.forEach(([match, href]) =&gt; {
		const replacementHref = urlMap.get(href);
		if (replacementHref) {
			const replacement = match.replace(href, replacementHref);
			content = content.split(match).join(replacement);
		}
	});

	return content;
};

Helpers.makeSet = (object, properties) =&gt; new Set(properties.reduce((memo, property) =&gt;
	memo.concat(object[property] ?
		Array.isArray(object[property]) ?
			object[property] :
			[object[property]] :
		[]), []));

Helpers.generateCollection = async ({ set, method, count, page, perPage, url }) =&gt; {
	if (!method) {
		method = db.getSortedSetRange.bind(null, set);
	} else if (set) {
		method = method.bind(null, set);
	}
	count = count || await db.sortedSetCard(set);
	const pageCount = Math.max(1, Math.ceil(count / perPage));
	let items = [];
	let paginate = true;

	if (!page &amp;&amp; pageCount === 1) {
		page = 1;
		paginate = false;
	}

	if (page) {
		const invalidPagination = page &lt; 1 || page &gt; pageCount;
		if (invalidPagination) {
			throw new Error(&#039;[[error:invalid-data]]&#039;);
		}

		const start = Math.max(0, ((page - 1) * perPage) - 1);
		const stop = Math.max(0, start + perPage - 1);
		items = await method.call(null, start, stop);
	}

	const object = {
		type: paginate &amp;&amp; items.length ? &#039;OrderedCollectionPage&#039; : &#039;OrderedCollection&#039;,
		totalItems: count,
	};

	if (items.length) {
		object.orderedItems = items;

		if (paginate) {
			object.partOf = url;
			object.next = page &lt; pageCount ? `${url}?page=${page + 1}` : null;
			object.prev = page &gt; 1 ? `${url}?page=${page - 1}` : null;
		}
	}

	if (paginate) {
		object.first = `${url}?page=1`;
		object.last = `${url}?page=${pageCount}`;
	}

	return object;
};

Helpers.generateDigest = (set) =&gt; {
	if (!(set instanceof Set)) {
		throw new Error(&#039;[[error:invalid-data]]&#039;);
	}

	return Array
		.from(set)
		.map(item =&gt; sha256(item))
		.reduce((memo, cur) =&gt; {
			const a = Buffer.from(memo, &#039;hex&#039;);
			const b = Buffer.from(cur, &#039;hex&#039;);
			// eslint-disable-next-line no-bitwise
			const result = a.map((x, i) =&gt; x ^ b[i]);
			return result.toString(&#039;hex&#039;);
		});
};</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
