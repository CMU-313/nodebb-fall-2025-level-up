<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/fraction.js/bigfraction.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/fraction.js/bigfraction.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">57.55</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">899</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">227.89</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">6.78</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/**
 * @license Fraction.js v4.2.1 20/08/2023
 * https://www.xarg.org/2014/03/rational-numbers-in-javascript/
 *
 * Copyright (c) 2023, Robert Eisele (robert@raw.org)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 **/


/**
 *
 * This class offers the possibility to calculate fractions.
 * You can pass a fraction in different formats. Either as array, as double, as string or as an integer.
 *
 * Array/Object form
 * [ 0 =&gt; &lt;numerator&gt;, 1 =&gt; &lt;denominator&gt; ]
 * [ n =&gt; &lt;numerator&gt;, d =&gt; &lt;denominator&gt; ]
 *
 * Integer form
 * - Single integer value
 *
 * Double form
 * - Single double value
 *
 * String form
 * 123.456 - a simple double
 * 123/456 - a string fraction
 * 123.&#039;456&#039; - a double with repeating decimal places
 * 123.(456) - synonym
 * 123.45&#039;6&#039; - a double with repeating last place
 * 123.45(6) - synonym
 *
 * Example:
 *
 * let f = new Fraction(&quot;9.4&#039;31&#039;&quot;);
 * f.mul([-4, 3]).div(4.9);
 *
 */

(function(root) {

  &quot;use strict&quot;;

  // Set Identity function to downgrade BigInt to Number if needed
  if (typeof BigInt === &#039;undefined&#039;) BigInt = function(n) { if (isNaN(n)) throw new Error(&quot;&quot;); return n; };

  const C_ONE = BigInt(1);
  const C_ZERO = BigInt(0);
  const C_TEN = BigInt(10);
  const C_TWO = BigInt(2);
  const C_FIVE = BigInt(5);

  // Maximum search depth for cyclic rational numbers. 2000 should be more than enough.
  // Example: 1/7 = 0.(142857) has 6 repeating decimal places.
  // If MAX_CYCLE_LEN gets reduced, long cycles will not be detected and toString() only gets the first 10 digits
  const MAX_CYCLE_LEN = 2000;

  // Parsed data to avoid calling &quot;new&quot; all the time
  const P = {
    &quot;s&quot;: C_ONE,
    &quot;n&quot;: C_ZERO,
    &quot;d&quot;: C_ONE
  };

  function assign(n, s) {

    try {
      n = BigInt(n);
    } catch (e) {
      throw InvalidParameter();
    }
    return n * s;
  }

  // Creates a new Fraction internally without the need of the bulky constructor
  function newFraction(n, d) {

    if (d === C_ZERO) {
      throw DivisionByZero();
    }

    const f = Object.create(Fraction.prototype);
    f[&quot;s&quot;] = n &lt; C_ZERO ? -C_ONE : C_ONE;

    n = n &lt; C_ZERO ? -n : n;

    const a = gcd(n, d);

    f[&quot;n&quot;] = n / a;
    f[&quot;d&quot;] = d / a;
    return f;
  }

  function factorize(num) {

    const factors = {};

    let n = num;
    let i = C_TWO;
    let s = C_FIVE - C_ONE;

    while (s &lt;= n) {

      while (n % i === C_ZERO) {
        n/= i;
        factors[i] = (factors[i] || C_ZERO) + C_ONE;
      }
      s+= C_ONE + C_TWO * i++;
    }

    if (n !== num) {
      if (n &gt; 1)
        factors[n] = (factors[n] || C_ZERO) + C_ONE;
    } else {
      factors[num] = (factors[num] || C_ZERO) + C_ONE;
    }
    return factors;
  }

  const parse = function(p1, p2) {

    let n = C_ZERO, d = C_ONE, s = C_ONE;

    if (p1 === undefined || p1 === null) {
      /* void */
    } else if (p2 !== undefined) {
      n = BigInt(p1);
      d = BigInt(p2);
      s = n * d;

      if (n % C_ONE !== C_ZERO || d % C_ONE !== C_ZERO) {
        throw NonIntegerParameter();
      }

    } else if (typeof p1 === &quot;object&quot;) {
      if (&quot;d&quot; in p1 &amp;&amp; &quot;n&quot; in p1) {
        n = BigInt(p1[&quot;n&quot;]);
        d = BigInt(p1[&quot;d&quot;]);
        if (&quot;s&quot; in p1)
          n*= BigInt(p1[&quot;s&quot;]);
      } else if (0 in p1) {
        n = BigInt(p1[0]);
        if (1 in p1)
          d = BigInt(p1[1]);
      } else if (p1 instanceof BigInt) {
        n = BigInt(p1);
      } else {
        throw InvalidParameter();
      }
      s = n * d;
    } else if (typeof p1 === &quot;bigint&quot;) {
      n = p1;
      s = p1;
      d = C_ONE;
    } else if (typeof p1 === &quot;number&quot;) {

      if (isNaN(p1)) {
        throw InvalidParameter();
      }

      if (p1 &lt; 0) {
        s = -C_ONE;
        p1 = -p1;
      }

      if (p1 % 1 === 0) {
        n = BigInt(p1);
      } else if (p1 &gt; 0) { // check for != 0, scale would become NaN (log(0)), which converges really slow

        let z = 1;

        let A = 0, B = 1;
        let C = 1, D = 1;

        let N = 10000000;

        if (p1 &gt;= 1) {
          z = 10 ** Math.floor(1 + Math.log10(p1));
          p1/= z;
        }

        // Using Farey Sequences

        while (B &lt;= N &amp;&amp; D &lt;= N) {
          let M = (A + C) / (B + D);

          if (p1 === M) {
            if (B + D &lt;= N) {
              n = A + C;
              d = B + D;
            } else if (D &gt; B) {
              n = C;
              d = D;
            } else {
              n = A;
              d = B;
            }
            break;

          } else {

            if (p1 &gt; M) {
              A+= C;
              B+= D;
            } else {
              C+= A;
              D+= B;
            }

            if (B &gt; N) {
              n = C;
              d = D;
            } else {
              n = A;
              d = B;
            }
          }
        }
        n = BigInt(n) * BigInt(z);
        d = BigInt(d);

      }

    } else if (typeof p1 === &quot;string&quot;) {

      let ndx = 0;

      let v = C_ZERO, w = C_ZERO, x = C_ZERO, y = C_ONE, z = C_ONE;

      let match = p1.match(/\d+|./g);

      if (match === null)
        throw InvalidParameter();

      if (match[ndx] === &#039;-&#039;) {// Check for minus sign at the beginning
        s = -C_ONE;
        ndx++;
      } else if (match[ndx] === &#039;+&#039;) {// Check for plus sign at the beginning
        ndx++;
      }

      if (match.length === ndx + 1) { // Check if it&#039;s just a simple number &quot;1234&quot;
        w = assign(match[ndx++], s);
      } else if (match[ndx + 1] === &#039;.&#039; || match[ndx] === &#039;.&#039;) { // Check if it&#039;s a decimal number

        if (match[ndx] !== &#039;.&#039;) { // Handle 0.5 and .5
          v = assign(match[ndx++], s);
        }
        ndx++;

        // Check for decimal places
        if (ndx + 1 === match.length || match[ndx + 1] === &#039;(&#039; &amp;&amp; match[ndx + 3] === &#039;)&#039; || match[ndx + 1] === &quot;&#039;&quot; &amp;&amp; match[ndx + 3] === &quot;&#039;&quot;) {
          w = assign(match[ndx], s);
          y = C_TEN ** BigInt(match[ndx].length);
          ndx++;
        }

        // Check for repeating places
        if (match[ndx] === &#039;(&#039; &amp;&amp; match[ndx + 2] === &#039;)&#039; || match[ndx] === &quot;&#039;&quot; &amp;&amp; match[ndx + 2] === &quot;&#039;&quot;) {
          x = assign(match[ndx + 1], s);
          z = C_TEN ** BigInt(match[ndx + 1].length) - C_ONE;
          ndx+= 3;
        }

      } else if (match[ndx + 1] === &#039;/&#039; || match[ndx + 1] === &#039;:&#039;) { // Check for a simple fraction &quot;123/456&quot; or &quot;123:456&quot;
        w = assign(match[ndx], s);
        y = assign(match[ndx + 2], C_ONE);
        ndx+= 3;
      } else if (match[ndx + 3] === &#039;/&#039; &amp;&amp; match[ndx + 1] === &#039; &#039;) { // Check for a complex fraction &quot;123 1/2&quot;
        v = assign(match[ndx], s);
        w = assign(match[ndx + 2], s);
        y = assign(match[ndx + 4], C_ONE);
        ndx+= 5;
      }

      if (match.length &lt;= ndx) { // Check for more tokens on the stack
        d = y * z;
        s = /* void */
        n = x + d * v + z * w;
      } else {
        throw InvalidParameter();
      }

    } else {
      throw InvalidParameter();
    }

    if (d === C_ZERO) {
      throw DivisionByZero();
    }

    P[&quot;s&quot;] = s &lt; C_ZERO ? -C_ONE : C_ONE;
    P[&quot;n&quot;] = n &lt; C_ZERO ? -n : n;
    P[&quot;d&quot;] = d &lt; C_ZERO ? -d : d;
  };

  function modpow(b, e, m) {

    let r = C_ONE;
    for (; e &gt; C_ZERO; b = (b * b) % m, e &gt;&gt;= C_ONE) {

      if (e &amp; C_ONE) {
        r = (r * b) % m;
      }
    }
    return r;
  }

  function cycleLen(n, d) {

    for (; d % C_TWO === C_ZERO;
      d/= C_TWO) {
    }

    for (; d % C_FIVE === C_ZERO;
      d/= C_FIVE) {
    }

    if (d === C_ONE) // Catch non-cyclic numbers
      return C_ZERO;

    // If we would like to compute really large numbers quicker, we could make use of Fermat&#039;s little theorem:
    // 10^(d-1) % d == 1
    // However, we don&#039;t need such large numbers and MAX_CYCLE_LEN should be the capstone,
    // as we want to translate the numbers to strings.

    let rem = C_TEN % d;
    let t = 1;

    for (; rem !== C_ONE; t++) {
      rem = rem * C_TEN % d;

      if (t &gt; MAX_CYCLE_LEN)
        return C_ZERO; // Returning 0 here means that we don&#039;t print it as a cyclic number. It&#039;s likely that the answer is `d-1`
    }
    return BigInt(t);
  }

  function cycleStart(n, d, len) {

    let rem1 = C_ONE;
    let rem2 = modpow(C_TEN, len, d);

    for (let t = 0; t &lt; 300; t++) { // s &lt; ~log10(Number.MAX_VALUE)
      // Solve 10^s == 10^(s+t) (mod d)

      if (rem1 === rem2)
        return BigInt(t);

      rem1 = rem1 * C_TEN % d;
      rem2 = rem2 * C_TEN % d;
    }
    return 0;
  }

  function gcd(a, b) {

    if (!a)
      return b;
    if (!b)
      return a;

    while (1) {
      a%= b;
      if (!a)
        return b;
      b%= a;
      if (!b)
        return a;
    }
  }

  /**
   * Module constructor
   *
   * @constructor
   * @param {number|Fraction=} a
   * @param {number=} b
   */
  function Fraction(a, b) {

    parse(a, b);

    if (this instanceof Fraction) {
      a = gcd(P[&quot;d&quot;], P[&quot;n&quot;]); // Abuse a
      this[&quot;s&quot;] = P[&quot;s&quot;];
      this[&quot;n&quot;] = P[&quot;n&quot;] / a;
      this[&quot;d&quot;] = P[&quot;d&quot;] / a;
    } else {
      return newFraction(P[&#039;s&#039;] * P[&#039;n&#039;], P[&#039;d&#039;]);
    }
  }

  var DivisionByZero = function() {return new Error(&quot;Division by Zero&quot;);};
  var InvalidParameter = function() {return new Error(&quot;Invalid argument&quot;);};
  var NonIntegerParameter = function() {return new Error(&quot;Parameters must be integer&quot;);};

  Fraction.prototype = {

    &quot;s&quot;: C_ONE,
    &quot;n&quot;: C_ZERO,
    &quot;d&quot;: C_ONE,

    /**
     * Calculates the absolute value
     *
     * Ex: new Fraction(-4).abs() =&gt; 4
     **/
    &quot;abs&quot;: function() {

      return newFraction(this[&quot;n&quot;], this[&quot;d&quot;]);
    },

    /**
     * Inverts the sign of the current fraction
     *
     * Ex: new Fraction(-4).neg() =&gt; 4
     **/
    &quot;neg&quot;: function() {

      return newFraction(-this[&quot;s&quot;] * this[&quot;n&quot;], this[&quot;d&quot;]);
    },

    /**
     * Adds two rational numbers
     *
     * Ex: new Fraction({n: 2, d: 3}).add(&quot;14.9&quot;) =&gt; 467 / 30
     **/
    &quot;add&quot;: function(a, b) {

      parse(a, b);
      return newFraction(
        this[&quot;s&quot;] * this[&quot;n&quot;] * P[&quot;d&quot;] + P[&quot;s&quot;] * this[&quot;d&quot;] * P[&quot;n&quot;],
        this[&quot;d&quot;] * P[&quot;d&quot;]
      );
    },

    /**
     * Subtracts two rational numbers
     *
     * Ex: new Fraction({n: 2, d: 3}).add(&quot;14.9&quot;) =&gt; -427 / 30
     **/
    &quot;sub&quot;: function(a, b) {

      parse(a, b);
      return newFraction(
        this[&quot;s&quot;] * this[&quot;n&quot;] * P[&quot;d&quot;] - P[&quot;s&quot;] * this[&quot;d&quot;] * P[&quot;n&quot;],
        this[&quot;d&quot;] * P[&quot;d&quot;]
      );
    },

    /**
     * Multiplies two rational numbers
     *
     * Ex: new Fraction(&quot;-17.(345)&quot;).mul(3) =&gt; 5776 / 111
     **/
    &quot;mul&quot;: function(a, b) {

      parse(a, b);
      return newFraction(
        this[&quot;s&quot;] * P[&quot;s&quot;] * this[&quot;n&quot;] * P[&quot;n&quot;],
        this[&quot;d&quot;] * P[&quot;d&quot;]
      );
    },

    /**
     * Divides two rational numbers
     *
     * Ex: new Fraction(&quot;-17.(345)&quot;).inverse().div(3)
     **/
    &quot;div&quot;: function(a, b) {

      parse(a, b);
      return newFraction(
        this[&quot;s&quot;] * P[&quot;s&quot;] * this[&quot;n&quot;] * P[&quot;d&quot;],
        this[&quot;d&quot;] * P[&quot;n&quot;]
      );
    },

    /**
     * Clones the actual object
     *
     * Ex: new Fraction(&quot;-17.(345)&quot;).clone()
     **/
    &quot;clone&quot;: function() {
      return newFraction(this[&#039;s&#039;] * this[&#039;n&#039;], this[&#039;d&#039;]);
    },

    /**
     * Calculates the modulo of two rational numbers - a more precise fmod
     *
     * Ex: new Fraction(&#039;4.(3)&#039;).mod([7, 8]) =&gt; (13/3) % (7/8) = (5/6)
     **/
    &quot;mod&quot;: function(a, b) {

      if (a === undefined) {
        return newFraction(this[&quot;s&quot;] * this[&quot;n&quot;] % this[&quot;d&quot;], C_ONE);
      }

      parse(a, b);
      if (0 === P[&quot;n&quot;] &amp;&amp; 0 === this[&quot;d&quot;]) {
        throw DivisionByZero();
      }

      /*
       * First silly attempt, kinda slow
       *
       return that[&quot;sub&quot;]({
       &quot;n&quot;: num[&quot;n&quot;] * Math.floor((this.n / this.d) / (num.n / num.d)),
       &quot;d&quot;: num[&quot;d&quot;],
       &quot;s&quot;: this[&quot;s&quot;]
       });*/

      /*
       * New attempt: a1 / b1 = a2 / b2 * q + r
       * =&gt; b2 * a1 = a2 * b1 * q + b1 * b2 * r
       * =&gt; (b2 * a1 % a2 * b1) / (b1 * b2)
       */
      return newFraction(
        this[&quot;s&quot;] * (P[&quot;d&quot;] * this[&quot;n&quot;]) % (P[&quot;n&quot;] * this[&quot;d&quot;]),
        P[&quot;d&quot;] * this[&quot;d&quot;]
      );
    },

    /**
     * Calculates the fractional gcd of two rational numbers
     *
     * Ex: new Fraction(5,8).gcd(3,7) =&gt; 1/56
     */
    &quot;gcd&quot;: function(a, b) {

      parse(a, b);

      // gcd(a / b, c / d) = gcd(a, c) / lcm(b, d)

      return newFraction(gcd(P[&quot;n&quot;], this[&quot;n&quot;]) * gcd(P[&quot;d&quot;], this[&quot;d&quot;]), P[&quot;d&quot;] * this[&quot;d&quot;]);
    },

    /**
     * Calculates the fractional lcm of two rational numbers
     *
     * Ex: new Fraction(5,8).lcm(3,7) =&gt; 15
     */
    &quot;lcm&quot;: function(a, b) {

      parse(a, b);

      // lcm(a / b, c / d) = lcm(a, c) / gcd(b, d)

      if (P[&quot;n&quot;] === C_ZERO &amp;&amp; this[&quot;n&quot;] === C_ZERO) {
        return newFraction(C_ZERO, C_ONE);
      }
      return newFraction(P[&quot;n&quot;] * this[&quot;n&quot;], gcd(P[&quot;n&quot;], this[&quot;n&quot;]) * gcd(P[&quot;d&quot;], this[&quot;d&quot;]));
    },

    /**
     * Gets the inverse of the fraction, means numerator and denominator are exchanged
     *
     * Ex: new Fraction([-3, 4]).inverse() =&gt; -4 / 3
     **/
    &quot;inverse&quot;: function() {
      return newFraction(this[&quot;s&quot;] * this[&quot;d&quot;], this[&quot;n&quot;]);
    },

    /**
     * Calculates the fraction to some integer exponent
     *
     * Ex: new Fraction(-1,2).pow(-3) =&gt; -8
     */
    &quot;pow&quot;: function(a, b) {

      parse(a, b);

      // Trivial case when exp is an integer

      if (P[&#039;d&#039;] === C_ONE) {

        if (P[&#039;s&#039;] &lt; C_ZERO) {
          return newFraction((this[&#039;s&#039;] * this[&quot;d&quot;]) ** P[&#039;n&#039;], this[&quot;n&quot;] ** P[&#039;n&#039;]);
        } else {
          return newFraction((this[&#039;s&#039;] * this[&quot;n&quot;]) ** P[&#039;n&#039;], this[&quot;d&quot;] ** P[&#039;n&#039;]);
        }
      }

      // Negative roots become complex
      //     (-a/b)^(c/d) = x
      // &lt;=&gt; (-1)^(c/d) * (a/b)^(c/d) = x
      // &lt;=&gt; (cos(pi) + i*sin(pi))^(c/d) * (a/b)^(c/d) = x
      // &lt;=&gt; (cos(c*pi/d) + i*sin(c*pi/d)) * (a/b)^(c/d) = x       # DeMoivre&#039;s formula
      // From which follows that only for c=0 the root is non-complex
      if (this[&#039;s&#039;] &lt; C_ZERO) return null;

      // Now prime factor n and d
      let N = factorize(this[&#039;n&#039;]);
      let D = factorize(this[&#039;d&#039;]);

      // Exponentiate and take root for n and d individually
      let n = C_ONE;
      let d = C_ONE;
      for (let k in N) {
        if (k === &#039;1&#039;) continue;
        if (k === &#039;0&#039;) {
          n = C_ZERO;
          break;
        }
        N[k]*= P[&#039;n&#039;];

        if (N[k] % P[&#039;d&#039;] === C_ZERO) {
          N[k]/= P[&#039;d&#039;];
        } else return null;
        n*= BigInt(k) ** N[k];
      }

      for (let k in D) {
        if (k === &#039;1&#039;) continue;
        D[k]*= P[&#039;n&#039;];

        if (D[k] % P[&#039;d&#039;] === C_ZERO) {
          D[k]/= P[&#039;d&#039;];
        } else return null;
        d*= BigInt(k) ** D[k];
      }

      if (P[&#039;s&#039;] &lt; C_ZERO) {
        return newFraction(d, n);
      }
      return newFraction(n, d);
    },

    /**
     * Check if two rational numbers are the same
     *
     * Ex: new Fraction(19.6).equals([98, 5]);
     **/
    &quot;equals&quot;: function(a, b) {

      parse(a, b);
      return this[&quot;s&quot;] * this[&quot;n&quot;] * P[&quot;d&quot;] === P[&quot;s&quot;] * P[&quot;n&quot;] * this[&quot;d&quot;]; // Same as compare() === 0
    },

    /**
     * Check if two rational numbers are the same
     *
     * Ex: new Fraction(19.6).equals([98, 5]);
     **/
    &quot;compare&quot;: function(a, b) {

      parse(a, b);
      let t = (this[&quot;s&quot;] * this[&quot;n&quot;] * P[&quot;d&quot;] - P[&quot;s&quot;] * P[&quot;n&quot;] * this[&quot;d&quot;]);

      return (C_ZERO &lt; t) - (t &lt; C_ZERO);
    },

    /**
     * Calculates the ceil of a rational number
     *
     * Ex: new Fraction(&#039;4.(3)&#039;).ceil() =&gt; (5 / 1)
     **/
    &quot;ceil&quot;: function(places) {

      places = C_TEN ** BigInt(places || 0);

      return newFraction(this[&quot;s&quot;] * places * this[&quot;n&quot;] / this[&quot;d&quot;] +
        (places * this[&quot;n&quot;] % this[&quot;d&quot;] &gt; C_ZERO &amp;&amp; this[&quot;s&quot;] &gt;= C_ZERO ? C_ONE : C_ZERO),
        places);
    },

    /**
     * Calculates the floor of a rational number
     *
     * Ex: new Fraction(&#039;4.(3)&#039;).floor() =&gt; (4 / 1)
     **/
    &quot;floor&quot;: function(places) {

      places = C_TEN ** BigInt(places || 0);

      return newFraction(this[&quot;s&quot;] * places * this[&quot;n&quot;] / this[&quot;d&quot;] -
        (places * this[&quot;n&quot;] % this[&quot;d&quot;] &gt; C_ZERO &amp;&amp; this[&quot;s&quot;] &lt; C_ZERO ? C_ONE : C_ZERO),
        places);
    },

    /**
     * Rounds a rational numbers
     *
     * Ex: new Fraction(&#039;4.(3)&#039;).round() =&gt; (4 / 1)
     **/
    &quot;round&quot;: function(places) {

      places = C_TEN ** BigInt(places || 0);

      /* Derivation:

      s &gt;= 0:
        round(n / d) = trunc(n / d) + (n % d) / d &gt;= 0.5 ? 1 : 0
                     = trunc(n / d) + 2(n % d) &gt;= d ? 1 : 0
      s &lt; 0:
        round(n / d) =-trunc(n / d) - (n % d) / d &gt; 0.5 ? 1 : 0
                     =-trunc(n / d) - 2(n % d) &gt; d ? 1 : 0

      =&gt;:

      round(s * n / d) = s * trunc(n / d) + s * (C + 2(n % d) &gt; d ? 1 : 0)
          where C = s &gt;= 0 ? 1 : 0, to fix the &gt;= for the positve case.
      */

      return newFraction(this[&quot;s&quot;] * places * this[&quot;n&quot;] / this[&quot;d&quot;] +
        this[&quot;s&quot;] * ((this[&quot;s&quot;] &gt;= C_ZERO ? C_ONE : C_ZERO) + C_TWO * (places * this[&quot;n&quot;] % this[&quot;d&quot;]) &gt; this[&quot;d&quot;] ? C_ONE : C_ZERO),
        places);
    },

    /**
     * Check if two rational numbers are divisible
     *
     * Ex: new Fraction(19.6).divisible(1.5);
     */
    &quot;divisible&quot;: function(a, b) {

      parse(a, b);
      return !(!(P[&quot;n&quot;] * this[&quot;d&quot;]) || ((this[&quot;n&quot;] * P[&quot;d&quot;]) % (P[&quot;n&quot;] * this[&quot;d&quot;])));
    },

    /**
     * Returns a decimal representation of the fraction
     *
     * Ex: new Fraction(&quot;100.&#039;91823&#039;&quot;).valueOf() =&gt; 100.91823918239183
     **/
    &#039;valueOf&#039;: function() {
      // Best we can do so far
      return Number(this[&quot;s&quot;] * this[&quot;n&quot;]) / Number(this[&quot;d&quot;]);
    },

    /**
     * Creates a string representation of a fraction with all digits
     *
     * Ex: new Fraction(&quot;100.&#039;91823&#039;&quot;).toString() =&gt; &quot;100.(91823)&quot;
     **/
    &#039;toString&#039;: function(dec) {

      let N = this[&quot;n&quot;];
      let D = this[&quot;d&quot;];

      function trunc(x) {
          return typeof x === &#039;bigint&#039; ? x : Math.floor(x);
      }

      dec = dec || 15; // 15 = decimal places when no repetition

      let cycLen = cycleLen(N, D); // Cycle length
      let cycOff = cycleStart(N, D, cycLen); // Cycle start

      let str = this[&#039;s&#039;] &lt; C_ZERO ? &quot;-&quot; : &quot;&quot;;

      // Append integer part
      str+= trunc(N / D);

      N%= D;
      N*= C_TEN;

      if (N)
        str+= &quot;.&quot;;

      if (cycLen) {

        for (let i = cycOff; i--;) {
          str+= trunc(N / D);
          N%= D;
          N*= C_TEN;
        }
        str+= &quot;(&quot;;
        for (let i = cycLen; i--;) {
          str+= trunc(N / D);
          N%= D;
          N*= C_TEN;
        }
        str+= &quot;)&quot;;
      } else {
        for (let i = dec; N &amp;&amp; i--;) {
          str+= trunc(N / D);
          N%= D;
          N*= C_TEN;
        }
      }
      return str;
    },

    /**
     * Returns a string-fraction representation of a Fraction object
     *
     * Ex: new Fraction(&quot;1.&#039;3&#039;&quot;).toFraction() =&gt; &quot;4 1/3&quot;
     **/
    &#039;toFraction&#039;: function(excludeWhole) {

      let n = this[&quot;n&quot;];
      let d = this[&quot;d&quot;];
      let str = this[&#039;s&#039;] &lt; C_ZERO ? &quot;-&quot; : &quot;&quot;;

      if (d === C_ONE) {
        str+= n;
      } else {
        let whole = n / d;
        if (excludeWhole &amp;&amp; whole &gt; C_ZERO) {
          str+= whole;
          str+= &quot; &quot;;
          n%= d;
        }

        str+= n;
        str+= &#039;/&#039;;
        str+= d;
      }
      return str;
    },

    /**
     * Returns a latex representation of a Fraction object
     *
     * Ex: new Fraction(&quot;1.&#039;3&#039;&quot;).toLatex() =&gt; &quot;\frac{4}{3}&quot;
     **/
    &#039;toLatex&#039;: function(excludeWhole) {

      let n = this[&quot;n&quot;];
      let d = this[&quot;d&quot;];
      let str = this[&#039;s&#039;] &lt; C_ZERO ? &quot;-&quot; : &quot;&quot;;

      if (d === C_ONE) {
        str+= n;
      } else {
        let whole = n / d;
        if (excludeWhole &amp;&amp; whole &gt; C_ZERO) {
          str+= whole;
          n%= d;
        }

        str+= &quot;\\frac{&quot;;
        str+= n;
        str+= &#039;}{&#039;;
        str+= d;
        str+= &#039;}&#039;;
      }
      return str;
    },

    /**
     * Returns an array of continued fraction elements
     *
     * Ex: new Fraction(&quot;7/8&quot;).toContinued() =&gt; [0,1,7]
     */
    &#039;toContinued&#039;: function() {

      let a = this[&#039;n&#039;];
      let b = this[&#039;d&#039;];
      let res = [];

      do {
        res.push(a / b);
        let t = a % b;
        a = b;
        b = t;
      } while (a !== C_ONE);

      return res;
    },

    &quot;simplify&quot;: function(eps) {

      eps = eps || 0.001;

      const thisABS = this[&#039;abs&#039;]();
      const cont = thisABS[&#039;toContinued&#039;]();

      for (let i = 1; i &lt; cont.length; i++) {

        let s = newFraction(cont[i - 1], C_ONE);
        for (let k = i - 2; k &gt;= 0; k--) {
          s = s[&#039;inverse&#039;]()[&#039;add&#039;](cont[k]);
        }

        if (Math.abs(s[&#039;sub&#039;](thisABS).valueOf()) &lt; eps) {
          return s[&#039;mul&#039;](this[&#039;s&#039;]);
        }
      }
      return this;
    }
  };

  if (typeof define === &quot;function&quot; &amp;&amp; define[&quot;amd&quot;]) {
    define([], function() {
      return Fraction;
    });
  } else if (typeof exports === &quot;object&quot;) {
    Object.defineProperty(exports, &quot;__esModule&quot;, { &#039;value&#039;: true });
    Fraction[&#039;default&#039;] = Fraction;
    Fraction[&#039;Fraction&#039;] = Fraction;
    module[&#039;exports&#039;] = Fraction;
  } else {
    root[&#039;Fraction&#039;] = Fraction;
  }

})(this);</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
