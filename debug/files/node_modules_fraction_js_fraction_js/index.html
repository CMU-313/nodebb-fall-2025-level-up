<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/fraction.js/fraction.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/fraction.js/fraction.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">58.22</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">891</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">249.75</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">6.48</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/**
 * @license Fraction.js v4.3.7 31/08/2023
 * https://www.xarg.org/2014/03/rational-numbers-in-javascript/
 *
 * Copyright (c) 2023, Robert Eisele (robert@raw.org)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 **/


/**
 *
 * This class offers the possibility to calculate fractions.
 * You can pass a fraction in different formats. Either as array, as double, as string or as an integer.
 *
 * Array/Object form
 * [ 0 =&gt; &lt;numerator&gt;, 1 =&gt; &lt;denominator&gt; ]
 * [ n =&gt; &lt;numerator&gt;, d =&gt; &lt;denominator&gt; ]
 *
 * Integer form
 * - Single integer value
 *
 * Double form
 * - Single double value
 *
 * String form
 * 123.456 - a simple double
 * 123/456 - a string fraction
 * 123.&#039;456&#039; - a double with repeating decimal places
 * 123.(456) - synonym
 * 123.45&#039;6&#039; - a double with repeating last place
 * 123.45(6) - synonym
 *
 * Example:
 *
 * var f = new Fraction(&quot;9.4&#039;31&#039;&quot;);
 * f.mul([-4, 3]).div(4.9);
 *
 */


// Maximum search depth for cyclic rational numbers. 2000 should be more than enough.
// Example: 1/7 = 0.(142857) has 6 repeating decimal places.
// If MAX_CYCLE_LEN gets reduced, long cycles will not be detected and toString() only gets the first 10 digits
var MAX_CYCLE_LEN = 2000;

// Parsed data to avoid calling &quot;new&quot; all the time
var P = {
  &quot;s&quot;: 1,
  &quot;n&quot;: 0,
  &quot;d&quot;: 1
};

function assign(n, s) {

  if (isNaN(n = parseInt(n, 10))) {
    throw InvalidParameter();
  }
  return n * s;
}

// Creates a new Fraction internally without the need of the bulky constructor
function newFraction(n, d) {

  if (d === 0) {
    throw DivisionByZero();
  }

  var f = Object.create(Fraction.prototype);
  f[&quot;s&quot;] = n &lt; 0 ? -1 : 1;

  n = n &lt; 0 ? -n : n;

  var a = gcd(n, d);

  f[&quot;n&quot;] = n / a;
  f[&quot;d&quot;] = d / a;
  return f;
}

function factorize(num) {

  var factors = {};

  var n = num;
  var i = 2;
  var s = 4;

  while (s &lt;= n) {

    while (n % i === 0) {
      n/= i;
      factors[i] = (factors[i] || 0) + 1;
    }
    s+= 1 + 2 * i++;
  }

  if (n !== num) {
    if (n &gt; 1)
      factors[n] = (factors[n] || 0) + 1;
  } else {
    factors[num] = (factors[num] || 0) + 1;
  }
  return factors;
}

var parse = function(p1, p2) {

  var n = 0, d = 1, s = 1;
  var v = 0, w = 0, x = 0, y = 1, z = 1;

  var A = 0, B = 1;
  var C = 1, D = 1;

  var N = 10000000;
  var M;

  if (p1 === undefined || p1 === null) {
    /* void */
  } else if (p2 !== undefined) {
    n = p1;
    d = p2;
    s = n * d;

    if (n % 1 !== 0 || d % 1 !== 0) {
      throw NonIntegerParameter();
    }

  } else
    switch (typeof p1) {

      case &quot;object&quot;:
        {
          if (&quot;d&quot; in p1 &amp;&amp; &quot;n&quot; in p1) {
            n = p1[&quot;n&quot;];
            d = p1[&quot;d&quot;];
            if (&quot;s&quot; in p1)
              n*= p1[&quot;s&quot;];
          } else if (0 in p1) {
            n = p1[0];
            if (1 in p1)
              d = p1[1];
          } else {
            throw InvalidParameter();
          }
          s = n * d;
          break;
        }
      case &quot;number&quot;:
        {
          if (p1 &lt; 0) {
            s = p1;
            p1 = -p1;
          }

          if (p1 % 1 === 0) {
            n = p1;
          } else if (p1 &gt; 0) { // check for != 0, scale would become NaN (log(0)), which converges really slow

            if (p1 &gt;= 1) {
              z = Math.pow(10, Math.floor(1 + Math.log(p1) / Math.LN10));
              p1/= z;
            }

            // Using Farey Sequences
            // http://www.johndcook.com/blog/2010/10/20/best-rational-approximation/

            while (B &lt;= N &amp;&amp; D &lt;= N) {
              M = (A + C) / (B + D);

              if (p1 === M) {
                if (B + D &lt;= N) {
                  n = A + C;
                  d = B + D;
                } else if (D &gt; B) {
                  n = C;
                  d = D;
                } else {
                  n = A;
                  d = B;
                }
                break;

              } else {

                if (p1 &gt; M) {
                  A+= C;
                  B+= D;
                } else {
                  C+= A;
                  D+= B;
                }

                if (B &gt; N) {
                  n = C;
                  d = D;
                } else {
                  n = A;
                  d = B;
                }
              }
            }
            n*= z;
          } else if (isNaN(p1) || isNaN(p2)) {
            d = n = NaN;
          }
          break;
        }
      case &quot;string&quot;:
        {
          B = p1.match(/\d+|./g);

          if (B === null)
            throw InvalidParameter();

          if (B[A] === &#039;-&#039;) {// Check for minus sign at the beginning
            s = -1;
            A++;
          } else if (B[A] === &#039;+&#039;) {// Check for plus sign at the beginning
            A++;
          }

          if (B.length === A + 1) { // Check if it&#039;s just a simple number &quot;1234&quot;
            w = assign(B[A++], s);
          } else if (B[A + 1] === &#039;.&#039; || B[A] === &#039;.&#039;) { // Check if it&#039;s a decimal number

            if (B[A] !== &#039;.&#039;) { // Handle 0.5 and .5
              v = assign(B[A++], s);
            }
            A++;

            // Check for decimal places
            if (A + 1 === B.length || B[A + 1] === &#039;(&#039; &amp;&amp; B[A + 3] === &#039;)&#039; || B[A + 1] === &quot;&#039;&quot; &amp;&amp; B[A + 3] === &quot;&#039;&quot;) {
              w = assign(B[A], s);
              y = Math.pow(10, B[A].length);
              A++;
            }

            // Check for repeating places
            if (B[A] === &#039;(&#039; &amp;&amp; B[A + 2] === &#039;)&#039; || B[A] === &quot;&#039;&quot; &amp;&amp; B[A + 2] === &quot;&#039;&quot;) {
              x = assign(B[A + 1], s);
              z = Math.pow(10, B[A + 1].length) - 1;
              A+= 3;
            }

          } else if (B[A + 1] === &#039;/&#039; || B[A + 1] === &#039;:&#039;) { // Check for a simple fraction &quot;123/456&quot; or &quot;123:456&quot;
            w = assign(B[A], s);
            y = assign(B[A + 2], 1);
            A+= 3;
          } else if (B[A + 3] === &#039;/&#039; &amp;&amp; B[A + 1] === &#039; &#039;) { // Check for a complex fraction &quot;123 1/2&quot;
            v = assign(B[A], s);
            w = assign(B[A + 2], s);
            y = assign(B[A + 4], 1);
            A+= 5;
          }

          if (B.length &lt;= A) { // Check for more tokens on the stack
            d = y * z;
            s = /* void */
            n = x + d * v + z * w;
            break;
          }

          /* Fall through on error */
        }
      default:
        throw InvalidParameter();
    }

  if (d === 0) {
    throw DivisionByZero();
  }

  P[&quot;s&quot;] = s &lt; 0 ? -1 : 1;
  P[&quot;n&quot;] = Math.abs(n);
  P[&quot;d&quot;] = Math.abs(d);
};

function modpow(b, e, m) {

  var r = 1;
  for (; e &gt; 0; b = (b * b) % m, e &gt;&gt;= 1) {

    if (e &amp; 1) {
      r = (r * b) % m;
    }
  }
  return r;
}


function cycleLen(n, d) {

  for (; d % 2 === 0;
    d/= 2) {
  }

  for (; d % 5 === 0;
    d/= 5) {
  }

  if (d === 1) // Catch non-cyclic numbers
    return 0;

  // If we would like to compute really large numbers quicker, we could make use of Fermat&#039;s little theorem:
  // 10^(d-1) % d == 1
  // However, we don&#039;t need such large numbers and MAX_CYCLE_LEN should be the capstone,
  // as we want to translate the numbers to strings.

  var rem = 10 % d;
  var t = 1;

  for (; rem !== 1; t++) {
    rem = rem * 10 % d;

    if (t &gt; MAX_CYCLE_LEN)
      return 0; // Returning 0 here means that we don&#039;t print it as a cyclic number. It&#039;s likely that the answer is `d-1`
  }
  return t;
}


function cycleStart(n, d, len) {

  var rem1 = 1;
  var rem2 = modpow(10, len, d);

  for (var t = 0; t &lt; 300; t++) { // s &lt; ~log10(Number.MAX_VALUE)
    // Solve 10^s == 10^(s+t) (mod d)

    if (rem1 === rem2)
      return t;

    rem1 = rem1 * 10 % d;
    rem2 = rem2 * 10 % d;
  }
  return 0;
}

function gcd(a, b) {

  if (!a)
    return b;
  if (!b)
    return a;

  while (1) {
    a%= b;
    if (!a)
      return b;
    b%= a;
    if (!b)
      return a;
  }
};

/**
 * Module constructor
 *
 * @constructor
 * @param {number|Fraction=} a
 * @param {number=} b
 */
export default function Fraction(a, b) {

  parse(a, b);

  if (this instanceof Fraction) {
    a = gcd(P[&quot;d&quot;], P[&quot;n&quot;]); // Abuse variable a
    this[&quot;s&quot;] = P[&quot;s&quot;];
    this[&quot;n&quot;] = P[&quot;n&quot;] / a;
    this[&quot;d&quot;] = P[&quot;d&quot;] / a;
  } else {
    return newFraction(P[&#039;s&#039;] * P[&#039;n&#039;], P[&#039;d&#039;]);
  }
}

var DivisionByZero = function() { return new Error(&quot;Division by Zero&quot;); };
var InvalidParameter = function() { return new Error(&quot;Invalid argument&quot;); };
var NonIntegerParameter = function() { return new Error(&quot;Parameters must be integer&quot;); };

Fraction.prototype = {

  &quot;s&quot;: 1,
  &quot;n&quot;: 0,
  &quot;d&quot;: 1,

  /**
   * Calculates the absolute value
   *
   * Ex: new Fraction(-4).abs() =&gt; 4
   **/
  &quot;abs&quot;: function() {

    return newFraction(this[&quot;n&quot;], this[&quot;d&quot;]);
  },

  /**
   * Inverts the sign of the current fraction
   *
   * Ex: new Fraction(-4).neg() =&gt; 4
   **/
  &quot;neg&quot;: function() {

    return newFraction(-this[&quot;s&quot;] * this[&quot;n&quot;], this[&quot;d&quot;]);
  },

  /**
   * Adds two rational numbers
   *
   * Ex: new Fraction({n: 2, d: 3}).add(&quot;14.9&quot;) =&gt; 467 / 30
   **/
  &quot;add&quot;: function(a, b) {

    parse(a, b);
    return newFraction(
      this[&quot;s&quot;] * this[&quot;n&quot;] * P[&quot;d&quot;] + P[&quot;s&quot;] * this[&quot;d&quot;] * P[&quot;n&quot;],
      this[&quot;d&quot;] * P[&quot;d&quot;]
    );
  },

  /**
   * Subtracts two rational numbers
   *
   * Ex: new Fraction({n: 2, d: 3}).add(&quot;14.9&quot;) =&gt; -427 / 30
   **/
  &quot;sub&quot;: function(a, b) {

    parse(a, b);
    return newFraction(
      this[&quot;s&quot;] * this[&quot;n&quot;] * P[&quot;d&quot;] - P[&quot;s&quot;] * this[&quot;d&quot;] * P[&quot;n&quot;],
      this[&quot;d&quot;] * P[&quot;d&quot;]
    );
  },

  /**
   * Multiplies two rational numbers
   *
   * Ex: new Fraction(&quot;-17.(345)&quot;).mul(3) =&gt; 5776 / 111
   **/
  &quot;mul&quot;: function(a, b) {

    parse(a, b);
    return newFraction(
      this[&quot;s&quot;] * P[&quot;s&quot;] * this[&quot;n&quot;] * P[&quot;n&quot;],
      this[&quot;d&quot;] * P[&quot;d&quot;]
    );
  },

  /**
   * Divides two rational numbers
   *
   * Ex: new Fraction(&quot;-17.(345)&quot;).inverse().div(3)
   **/
  &quot;div&quot;: function(a, b) {

    parse(a, b);
    return newFraction(
      this[&quot;s&quot;] * P[&quot;s&quot;] * this[&quot;n&quot;] * P[&quot;d&quot;],
      this[&quot;d&quot;] * P[&quot;n&quot;]
    );
  },

  /**
   * Clones the actual object
   *
   * Ex: new Fraction(&quot;-17.(345)&quot;).clone()
   **/
  &quot;clone&quot;: function() {
    return newFraction(this[&#039;s&#039;] * this[&#039;n&#039;], this[&#039;d&#039;]);
  },

  /**
   * Calculates the modulo of two rational numbers - a more precise fmod
   *
   * Ex: new Fraction(&#039;4.(3)&#039;).mod([7, 8]) =&gt; (13/3) % (7/8) = (5/6)
   **/
  &quot;mod&quot;: function(a, b) {

    if (isNaN(this[&#039;n&#039;]) || isNaN(this[&#039;d&#039;])) {
      return new Fraction(NaN);
    }

    if (a === undefined) {
      return newFraction(this[&quot;s&quot;] * this[&quot;n&quot;] % this[&quot;d&quot;], 1);
    }

    parse(a, b);
    if (0 === P[&quot;n&quot;] &amp;&amp; 0 === this[&quot;d&quot;]) {
      throw DivisionByZero();
    }

    /*
     * First silly attempt, kinda slow
     *
     return that[&quot;sub&quot;]({
     &quot;n&quot;: num[&quot;n&quot;] * Math.floor((this.n / this.d) / (num.n / num.d)),
     &quot;d&quot;: num[&quot;d&quot;],
     &quot;s&quot;: this[&quot;s&quot;]
     });*/

    /*
     * New attempt: a1 / b1 = a2 / b2 * q + r
     * =&gt; b2 * a1 = a2 * b1 * q + b1 * b2 * r
     * =&gt; (b2 * a1 % a2 * b1) / (b1 * b2)
     */
    return newFraction(
      this[&quot;s&quot;] * (P[&quot;d&quot;] * this[&quot;n&quot;]) % (P[&quot;n&quot;] * this[&quot;d&quot;]),
      P[&quot;d&quot;] * this[&quot;d&quot;]
    );
  },

  /**
   * Calculates the fractional gcd of two rational numbers
   *
   * Ex: new Fraction(5,8).gcd(3,7) =&gt; 1/56
   */
  &quot;gcd&quot;: function(a, b) {

    parse(a, b);

    // gcd(a / b, c / d) = gcd(a, c) / lcm(b, d)

    return newFraction(gcd(P[&quot;n&quot;], this[&quot;n&quot;]) * gcd(P[&quot;d&quot;], this[&quot;d&quot;]), P[&quot;d&quot;] * this[&quot;d&quot;]);
  },

  /**
   * Calculates the fractional lcm of two rational numbers
   *
   * Ex: new Fraction(5,8).lcm(3,7) =&gt; 15
   */
  &quot;lcm&quot;: function(a, b) {

    parse(a, b);

    // lcm(a / b, c / d) = lcm(a, c) / gcd(b, d)

    if (P[&quot;n&quot;] === 0 &amp;&amp; this[&quot;n&quot;] === 0) {
      return newFraction(0, 1);
    }
    return newFraction(P[&quot;n&quot;] * this[&quot;n&quot;], gcd(P[&quot;n&quot;], this[&quot;n&quot;]) * gcd(P[&quot;d&quot;], this[&quot;d&quot;]));
  },

  /**
   * Calculates the ceil of a rational number
   *
   * Ex: new Fraction(&#039;4.(3)&#039;).ceil() =&gt; (5 / 1)
   **/
  &quot;ceil&quot;: function(places) {

    places = Math.pow(10, places || 0);

    if (isNaN(this[&quot;n&quot;]) || isNaN(this[&quot;d&quot;])) {
      return new Fraction(NaN);
    }
    return newFraction(Math.ceil(places * this[&quot;s&quot;] * this[&quot;n&quot;] / this[&quot;d&quot;]), places);
  },

  /**
   * Calculates the floor of a rational number
   *
   * Ex: new Fraction(&#039;4.(3)&#039;).floor() =&gt; (4 / 1)
   **/
  &quot;floor&quot;: function(places) {

    places = Math.pow(10, places || 0);

    if (isNaN(this[&quot;n&quot;]) || isNaN(this[&quot;d&quot;])) {
      return new Fraction(NaN);
    }
    return newFraction(Math.floor(places * this[&quot;s&quot;] * this[&quot;n&quot;] / this[&quot;d&quot;]), places);
  },

  /**
   * Rounds a rational number
   *
   * Ex: new Fraction(&#039;4.(3)&#039;).round() =&gt; (4 / 1)
   **/
  &quot;round&quot;: function(places) {

    places = Math.pow(10, places || 0);

    if (isNaN(this[&quot;n&quot;]) || isNaN(this[&quot;d&quot;])) {
      return new Fraction(NaN);
    }
    return newFraction(Math.round(places * this[&quot;s&quot;] * this[&quot;n&quot;] / this[&quot;d&quot;]), places);
  },

  /**
   * Rounds a rational number to a multiple of another rational number
   *
   * Ex: new Fraction(&#039;0.9&#039;).roundTo(&quot;1/8&quot;) =&gt; 7 / 8
   **/
  &quot;roundTo&quot;: function(a, b) {

    /*
    k * x/y ≤ a/b &lt; (k+1) * x/y
    ⇔ k ≤ a/b / (x/y) &lt; (k+1)
    ⇔ k = floor(a/b * y/x)
    */

    parse(a, b);

    return newFraction(this[&#039;s&#039;] * Math.round(this[&#039;n&#039;] * P[&#039;d&#039;] / (this[&#039;d&#039;] * P[&#039;n&#039;])) * P[&#039;n&#039;], P[&#039;d&#039;]);
  },

  /**
   * Gets the inverse of the fraction, means numerator and denominator are exchanged
   *
   * Ex: new Fraction([-3, 4]).inverse() =&gt; -4 / 3
   **/
  &quot;inverse&quot;: function() {

    return newFraction(this[&quot;s&quot;] * this[&quot;d&quot;], this[&quot;n&quot;]);
  },

  /**
   * Calculates the fraction to some rational exponent, if possible
   *
   * Ex: new Fraction(-1,2).pow(-3) =&gt; -8
   */
  &quot;pow&quot;: function(a, b) {

    parse(a, b);

    // Trivial case when exp is an integer

    if (P[&#039;d&#039;] === 1) {

      if (P[&#039;s&#039;] &lt; 0) {
        return newFraction(Math.pow(this[&#039;s&#039;] * this[&quot;d&quot;], P[&#039;n&#039;]), Math.pow(this[&quot;n&quot;], P[&#039;n&#039;]));
      } else {
        return newFraction(Math.pow(this[&#039;s&#039;] * this[&quot;n&quot;], P[&#039;n&#039;]), Math.pow(this[&quot;d&quot;], P[&#039;n&#039;]));
      }
    }

    // Negative roots become complex
    //     (-a/b)^(c/d) = x
    // &lt;=&gt; (-1)^(c/d) * (a/b)^(c/d) = x
    // &lt;=&gt; (cos(pi) + i*sin(pi))^(c/d) * (a/b)^(c/d) = x         # rotate 1 by 180°
    // &lt;=&gt; (cos(c*pi/d) + i*sin(c*pi/d)) * (a/b)^(c/d) = x       # DeMoivre&#039;s formula in Q ( https://proofwiki.org/wiki/De_Moivre%27s_Formula/Rational_Index )
    // From which follows that only for c=0 the root is non-complex. c/d is a reduced fraction, so that sin(c/dpi)=0 occurs for d=1, which is handled by our trivial case.
    if (this[&#039;s&#039;] &lt; 0) return null;

    // Now prime factor n and d
    var N = factorize(this[&#039;n&#039;]);
    var D = factorize(this[&#039;d&#039;]);

    // Exponentiate and take root for n and d individually
    var n = 1;
    var d = 1;
    for (var k in N) {
      if (k === &#039;1&#039;) continue;
      if (k === &#039;0&#039;) {
        n = 0;
        break;
      }
      N[k]*= P[&#039;n&#039;];

      if (N[k] % P[&#039;d&#039;] === 0) {
        N[k]/= P[&#039;d&#039;];
      } else return null;
      n*= Math.pow(k, N[k]);
    }

    for (var k in D) {
      if (k === &#039;1&#039;) continue;
      D[k]*= P[&#039;n&#039;];

      if (D[k] % P[&#039;d&#039;] === 0) {
        D[k]/= P[&#039;d&#039;];
      } else return null;
      d*= Math.pow(k, D[k]);
    }

    if (P[&#039;s&#039;] &lt; 0) {
      return newFraction(d, n);
    }
    return newFraction(n, d);
  },

  /**
   * Check if two rational numbers are the same
   *
   * Ex: new Fraction(19.6).equals([98, 5]);
   **/
  &quot;equals&quot;: function(a, b) {

    parse(a, b);
    return this[&quot;s&quot;] * this[&quot;n&quot;] * P[&quot;d&quot;] === P[&quot;s&quot;] * P[&quot;n&quot;] * this[&quot;d&quot;]; // Same as compare() === 0
  },

  /**
   * Check if two rational numbers are the same
   *
   * Ex: new Fraction(19.6).equals([98, 5]);
   **/
  &quot;compare&quot;: function(a, b) {

    parse(a, b);
    var t = (this[&quot;s&quot;] * this[&quot;n&quot;] * P[&quot;d&quot;] - P[&quot;s&quot;] * P[&quot;n&quot;] * this[&quot;d&quot;]);
    return (0 &lt; t) - (t &lt; 0);
  },

  &quot;simplify&quot;: function(eps) {

    if (isNaN(this[&#039;n&#039;]) || isNaN(this[&#039;d&#039;])) {
      return this;
    }

    eps = eps || 0.001;

    var thisABS = this[&#039;abs&#039;]();
    var cont = thisABS[&#039;toContinued&#039;]();

    for (var i = 1; i &lt; cont.length; i++) {

      var s = newFraction(cont[i - 1], 1);
      for (var k = i - 2; k &gt;= 0; k--) {
        s = s[&#039;inverse&#039;]()[&#039;add&#039;](cont[k]);
      }

      if (Math.abs(s[&#039;sub&#039;](thisABS).valueOf()) &lt; eps) {
        return s[&#039;mul&#039;](this[&#039;s&#039;]);
      }
    }
    return this;
  },

  /**
   * Check if two rational numbers are divisible
   *
   * Ex: new Fraction(19.6).divisible(1.5);
   */
  &quot;divisible&quot;: function(a, b) {

    parse(a, b);
    return !(!(P[&quot;n&quot;] * this[&quot;d&quot;]) || ((this[&quot;n&quot;] * P[&quot;d&quot;]) % (P[&quot;n&quot;] * this[&quot;d&quot;])));
  },

  /**
   * Returns a decimal representation of the fraction
   *
   * Ex: new Fraction(&quot;100.&#039;91823&#039;&quot;).valueOf() =&gt; 100.91823918239183
   **/
  &#039;valueOf&#039;: function() {

    return this[&quot;s&quot;] * this[&quot;n&quot;] / this[&quot;d&quot;];
  },

  /**
   * Returns a string-fraction representation of a Fraction object
   *
   * Ex: new Fraction(&quot;1.&#039;3&#039;&quot;).toFraction(true) =&gt; &quot;4 1/3&quot;
   **/
  &#039;toFraction&#039;: function(excludeWhole) {

    var whole, str = &quot;&quot;;
    var n = this[&quot;n&quot;];
    var d = this[&quot;d&quot;];
    if (this[&quot;s&quot;] &lt; 0) {
      str+= &#039;-&#039;;
    }

    if (d === 1) {
      str+= n;
    } else {

      if (excludeWhole &amp;&amp; (whole = Math.floor(n / d)) &gt; 0) {
        str+= whole;
        str+= &quot; &quot;;
        n%= d;
      }

      str+= n;
      str+= &#039;/&#039;;
      str+= d;
    }
    return str;
  },

  /**
   * Returns a latex representation of a Fraction object
   *
   * Ex: new Fraction(&quot;1.&#039;3&#039;&quot;).toLatex() =&gt; &quot;\frac{4}{3}&quot;
   **/
  &#039;toLatex&#039;: function(excludeWhole) {

    var whole, str = &quot;&quot;;
    var n = this[&quot;n&quot;];
    var d = this[&quot;d&quot;];
    if (this[&quot;s&quot;] &lt; 0) {
      str+= &#039;-&#039;;
    }

    if (d === 1) {
      str+= n;
    } else {

      if (excludeWhole &amp;&amp; (whole = Math.floor(n / d)) &gt; 0) {
        str+= whole;
        n%= d;
      }

      str+= &quot;\\frac{&quot;;
      str+= n;
      str+= &#039;}{&#039;;
      str+= d;
      str+= &#039;}&#039;;
    }
    return str;
  },

  /**
   * Returns an array of continued fraction elements
   *
   * Ex: new Fraction(&quot;7/8&quot;).toContinued() =&gt; [0,1,7]
   */
  &#039;toContinued&#039;: function() {

    var t;
    var a = this[&#039;n&#039;];
    var b = this[&#039;d&#039;];
    var res = [];

    if (isNaN(a) || isNaN(b)) {
      return res;
    }

    do {
      res.push(Math.floor(a / b));
      t = a % b;
      a = b;
      b = t;
    } while (a !== 1);

    return res;
  },

  /**
   * Creates a string representation of a fraction with all digits
   *
   * Ex: new Fraction(&quot;100.&#039;91823&#039;&quot;).toString() =&gt; &quot;100.(91823)&quot;
   **/
  &#039;toString&#039;: function(dec) {

    var N = this[&quot;n&quot;];
    var D = this[&quot;d&quot;];

    if (isNaN(N) || isNaN(D)) {
      return &quot;NaN&quot;;
    }

    dec = dec || 15; // 15 = decimal places when no repetation

    var cycLen = cycleLen(N, D); // Cycle length
    var cycOff = cycleStart(N, D, cycLen); // Cycle start

    var str = this[&#039;s&#039;] &lt; 0 ? &quot;-&quot; : &quot;&quot;;

    str+= N / D | 0;

    N%= D;
    N*= 10;

    if (N)
      str+= &quot;.&quot;;

    if (cycLen) {

      for (var i = cycOff; i--;) {
        str+= N / D | 0;
        N%= D;
        N*= 10;
      }
      str+= &quot;(&quot;;
      for (var i = cycLen; i--;) {
        str+= N / D | 0;
        N%= D;
        N*= 10;
      }
      str+= &quot;)&quot;;
    } else {
      for (var i = dec; N &amp;&amp; i--;) {
        str+= N / D | 0;
        N%= D;
        N*= 10;
      }
    }
    return str;
  }
};</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
