<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/highlight.js/lib/languages/swift.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/highlight.js/lib/languages/swift.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">57.95</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">885</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">26.77</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">4.00</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/**
 * @param {string} value
 * @returns {RegExp}
 * */

/**
 * @param {RegExp | string } re
 * @returns {string}
 */
function source(re) {
  if (!re) return null;
  if (typeof re === &quot;string&quot;) return re;

  return re.source;
}

/**
 * @param {RegExp | string } re
 * @returns {string}
 */
function lookahead(re) {
  return concat(&#039;(?=&#039;, re, &#039;)&#039;);
}

/**
 * @param {...(RegExp | string) } args
 * @returns {string}
 */
function concat(...args) {
  const joined = args.map((x) =&gt; source(x)).join(&quot;&quot;);
  return joined;
}

/**
 * @param { Array&lt;string | RegExp | Object&gt; } args
 * @returns {object}
 */
function stripOptionsFromArgs(args) {
  const opts = args[args.length - 1];

  if (typeof opts === &#039;object&#039; &amp;&amp; opts.constructor === Object) {
    args.splice(args.length - 1, 1);
    return opts;
  } else {
    return {};
  }
}

/** @typedef { {capture?: boolean} } RegexEitherOptions */

/**
 * Any of the passed expresssions may match
 *
 * Creates a huge this | this | that | that match
 * @param {(RegExp | string)[] | [...(RegExp | string)[], RegexEitherOptions]} args
 * @returns {string}
 */
function either(...args) {
  /** @type { object &amp; {capture?: boolean} }  */
  const opts = stripOptionsFromArgs(args);
  const joined = &#039;(&#039;
    + (opts.capture ? &quot;&quot; : &quot;?:&quot;)
    + args.map((x) =&gt; source(x)).join(&quot;|&quot;) + &quot;)&quot;;
  return joined;
}

const keywordWrapper = keyword =&gt; concat(
  /\b/,
  keyword,
  /\w$/.test(keyword) ? /\b/ : /\B/
);

// Keywords that require a leading dot.
const dotKeywords = [
  &#039;Protocol&#039;, // contextual
  &#039;Type&#039; // contextual
].map(keywordWrapper);

// Keywords that may have a leading dot.
const optionalDotKeywords = [
  &#039;init&#039;,
  &#039;self&#039;
].map(keywordWrapper);

// should register as keyword, not type
const keywordTypes = [
  &#039;Any&#039;,
  &#039;Self&#039;
];

// Regular keywords and literals.
const keywords = [
  // strings below will be fed into the regular `keywords` engine while regex
  // will result in additional modes being created to scan for those keywords to
  // avoid conflicts with other rules
  &#039;actor&#039;,
  &#039;associatedtype&#039;,
  &#039;async&#039;,
  &#039;await&#039;,
  /as\?/, // operator
  /as!/, // operator
  &#039;as&#039;, // operator
  &#039;break&#039;,
  &#039;case&#039;,
  &#039;catch&#039;,
  &#039;class&#039;,
  &#039;continue&#039;,
  &#039;convenience&#039;, // contextual
  &#039;default&#039;,
  &#039;defer&#039;,
  &#039;deinit&#039;,
  &#039;didSet&#039;, // contextual
  &#039;do&#039;,
  &#039;dynamic&#039;, // contextual
  &#039;else&#039;,
  &#039;enum&#039;,
  &#039;extension&#039;,
  &#039;fallthrough&#039;,
  /fileprivate\(set\)/,
  &#039;fileprivate&#039;,
  &#039;final&#039;, // contextual
  &#039;for&#039;,
  &#039;func&#039;,
  &#039;get&#039;, // contextual
  &#039;guard&#039;,
  &#039;if&#039;,
  &#039;import&#039;,
  &#039;indirect&#039;, // contextual
  &#039;infix&#039;, // contextual
  /init\?/,
  /init!/,
  &#039;inout&#039;,
  /internal\(set\)/,
  &#039;internal&#039;,
  &#039;in&#039;,
  &#039;is&#039;, // operator
  &#039;isolated&#039;, // contextual
  &#039;nonisolated&#039;, // contextual
  &#039;lazy&#039;, // contextual
  &#039;let&#039;,
  &#039;mutating&#039;, // contextual
  &#039;nonmutating&#039;, // contextual
  /open\(set\)/, // contextual
  &#039;open&#039;, // contextual
  &#039;operator&#039;,
  &#039;optional&#039;, // contextual
  &#039;override&#039;, // contextual
  &#039;postfix&#039;, // contextual
  &#039;precedencegroup&#039;,
  &#039;prefix&#039;, // contextual
  /private\(set\)/,
  &#039;private&#039;,
  &#039;protocol&#039;,
  /public\(set\)/,
  &#039;public&#039;,
  &#039;repeat&#039;,
  &#039;required&#039;, // contextual
  &#039;rethrows&#039;,
  &#039;return&#039;,
  &#039;set&#039;, // contextual
  &#039;some&#039;, // contextual
  &#039;static&#039;,
  &#039;struct&#039;,
  &#039;subscript&#039;,
  &#039;super&#039;,
  &#039;switch&#039;,
  &#039;throws&#039;,
  &#039;throw&#039;,
  /try\?/, // operator
  /try!/, // operator
  &#039;try&#039;, // operator
  &#039;typealias&#039;,
  /unowned\(safe\)/, // contextual
  /unowned\(unsafe\)/, // contextual
  &#039;unowned&#039;, // contextual
  &#039;var&#039;,
  &#039;weak&#039;, // contextual
  &#039;where&#039;,
  &#039;while&#039;,
  &#039;willSet&#039; // contextual
];

// NOTE: Contextual keywords are reserved only in specific contexts.
// Ideally, these should be matched using modes to avoid false positives.

// Literals.
const literals = [
  &#039;false&#039;,
  &#039;nil&#039;,
  &#039;true&#039;
];

// Keywords used in precedence groups.
const precedencegroupKeywords = [
  &#039;assignment&#039;,
  &#039;associativity&#039;,
  &#039;higherThan&#039;,
  &#039;left&#039;,
  &#039;lowerThan&#039;,
  &#039;none&#039;,
  &#039;right&#039;
];

// Keywords that start with a number sign (#).
// #(un)available is handled separately.
const numberSignKeywords = [
  &#039;#colorLiteral&#039;,
  &#039;#column&#039;,
  &#039;#dsohandle&#039;,
  &#039;#else&#039;,
  &#039;#elseif&#039;,
  &#039;#endif&#039;,
  &#039;#error&#039;,
  &#039;#file&#039;,
  &#039;#fileID&#039;,
  &#039;#fileLiteral&#039;,
  &#039;#filePath&#039;,
  &#039;#function&#039;,
  &#039;#if&#039;,
  &#039;#imageLiteral&#039;,
  &#039;#keyPath&#039;,
  &#039;#line&#039;,
  &#039;#selector&#039;,
  &#039;#sourceLocation&#039;,
  &#039;#warn_unqualified_access&#039;,
  &#039;#warning&#039;
];

// Global functions in the Standard Library.
const builtIns = [
  &#039;abs&#039;,
  &#039;all&#039;,
  &#039;any&#039;,
  &#039;assert&#039;,
  &#039;assertionFailure&#039;,
  &#039;debugPrint&#039;,
  &#039;dump&#039;,
  &#039;fatalError&#039;,
  &#039;getVaList&#039;,
  &#039;isKnownUniquelyReferenced&#039;,
  &#039;max&#039;,
  &#039;min&#039;,
  &#039;numericCast&#039;,
  &#039;pointwiseMax&#039;,
  &#039;pointwiseMin&#039;,
  &#039;precondition&#039;,
  &#039;preconditionFailure&#039;,
  &#039;print&#039;,
  &#039;readLine&#039;,
  &#039;repeatElement&#039;,
  &#039;sequence&#039;,
  &#039;stride&#039;,
  &#039;swap&#039;,
  &#039;swift_unboxFromSwiftValueWithType&#039;,
  &#039;transcode&#039;,
  &#039;type&#039;,
  &#039;unsafeBitCast&#039;,
  &#039;unsafeDowncast&#039;,
  &#039;withExtendedLifetime&#039;,
  &#039;withUnsafeMutablePointer&#039;,
  &#039;withUnsafePointer&#039;,
  &#039;withVaList&#039;,
  &#039;withoutActuallyEscaping&#039;,
  &#039;zip&#039;
];

// Valid first characters for operators.
const operatorHead = either(
  /[/=\-+!*%&lt;&gt;&amp;|^~?]/,
  /[\u00A1-\u00A7]/,
  /[\u00A9\u00AB]/,
  /[\u00AC\u00AE]/,
  /[\u00B0\u00B1]/,
  /[\u00B6\u00BB\u00BF\u00D7\u00F7]/,
  /[\u2016-\u2017]/,
  /[\u2020-\u2027]/,
  /[\u2030-\u203E]/,
  /[\u2041-\u2053]/,
  /[\u2055-\u205E]/,
  /[\u2190-\u23FF]/,
  /[\u2500-\u2775]/,
  /[\u2794-\u2BFF]/,
  /[\u2E00-\u2E7F]/,
  /[\u3001-\u3003]/,
  /[\u3008-\u3020]/,
  /[\u3030]/
);

// Valid characters for operators.
const operatorCharacter = either(
  operatorHead,
  /[\u0300-\u036F]/,
  /[\u1DC0-\u1DFF]/,
  /[\u20D0-\u20FF]/,
  /[\uFE00-\uFE0F]/,
  /[\uFE20-\uFE2F]/
  // TODO: The following characters are also allowed, but the regex isn&#039;t supported yet.
  // /[\u{E0100}-\u{E01EF}]/u
);

// Valid operator.
const operator = concat(operatorHead, operatorCharacter, &#039;*&#039;);

// Valid first characters for identifiers.
const identifierHead = either(
  /[a-zA-Z_]/,
  /[\u00A8\u00AA\u00AD\u00AF\u00B2-\u00B5\u00B7-\u00BA]/,
  /[\u00BC-\u00BE\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF]/,
  /[\u0100-\u02FF\u0370-\u167F\u1681-\u180D\u180F-\u1DBF]/,
  /[\u1E00-\u1FFF]/,
  /[\u200B-\u200D\u202A-\u202E\u203F-\u2040\u2054\u2060-\u206F]/,
  /[\u2070-\u20CF\u2100-\u218F\u2460-\u24FF\u2776-\u2793]/,
  /[\u2C00-\u2DFF\u2E80-\u2FFF]/,
  /[\u3004-\u3007\u3021-\u302F\u3031-\u303F\u3040-\uD7FF]/,
  /[\uF900-\uFD3D\uFD40-\uFDCF\uFDF0-\uFE1F\uFE30-\uFE44]/,
  /[\uFE47-\uFEFE\uFF00-\uFFFD]/ // Should be /[\uFE47-\uFFFD]/, but we have to exclude FEFF.
  // The following characters are also allowed, but the regexes aren&#039;t supported yet.
  // /[\u{10000}-\u{1FFFD}\u{20000-\u{2FFFD}\u{30000}-\u{3FFFD}\u{40000}-\u{4FFFD}]/u,
  // /[\u{50000}-\u{5FFFD}\u{60000-\u{6FFFD}\u{70000}-\u{7FFFD}\u{80000}-\u{8FFFD}]/u,
  // /[\u{90000}-\u{9FFFD}\u{A0000-\u{AFFFD}\u{B0000}-\u{BFFFD}\u{C0000}-\u{CFFFD}]/u,
  // /[\u{D0000}-\u{DFFFD}\u{E0000-\u{EFFFD}]/u
);

// Valid characters for identifiers.
const identifierCharacter = either(
  identifierHead,
  /\d/,
  /[\u0300-\u036F\u1DC0-\u1DFF\u20D0-\u20FF\uFE20-\uFE2F]/
);

// Valid identifier.
const identifier = concat(identifierHead, identifierCharacter, &#039;*&#039;);

// Valid type identifier.
const typeIdentifier = concat(/[A-Z]/, identifierCharacter, &#039;*&#039;);

// Built-in attributes, which are highlighted as keywords.
// @available is handled separately.
const keywordAttributes = [
  &#039;autoclosure&#039;,
  concat(/convention\(/, either(&#039;swift&#039;, &#039;block&#039;, &#039;c&#039;), /\)/),
  &#039;discardableResult&#039;,
  &#039;dynamicCallable&#039;,
  &#039;dynamicMemberLookup&#039;,
  &#039;escaping&#039;,
  &#039;frozen&#039;,
  &#039;GKInspectable&#039;,
  &#039;IBAction&#039;,
  &#039;IBDesignable&#039;,
  &#039;IBInspectable&#039;,
  &#039;IBOutlet&#039;,
  &#039;IBSegueAction&#039;,
  &#039;inlinable&#039;,
  &#039;main&#039;,
  &#039;nonobjc&#039;,
  &#039;NSApplicationMain&#039;,
  &#039;NSCopying&#039;,
  &#039;NSManaged&#039;,
  concat(/objc\(/, identifier, /\)/),
  &#039;objc&#039;,
  &#039;objcMembers&#039;,
  &#039;propertyWrapper&#039;,
  &#039;requires_stored_property_inits&#039;,
  &#039;resultBuilder&#039;,
  &#039;testable&#039;,
  &#039;UIApplicationMain&#039;,
  &#039;unknown&#039;,
  &#039;usableFromInline&#039;
];

// Contextual keywords used in @available and #(un)available.
const availabilityKeywords = [
  &#039;iOS&#039;,
  &#039;iOSApplicationExtension&#039;,
  &#039;macOS&#039;,
  &#039;macOSApplicationExtension&#039;,
  &#039;macCatalyst&#039;,
  &#039;macCatalystApplicationExtension&#039;,
  &#039;watchOS&#039;,
  &#039;watchOSApplicationExtension&#039;,
  &#039;tvOS&#039;,
  &#039;tvOSApplicationExtension&#039;,
  &#039;swift&#039;
];

/*
Language: Swift
Description: Swift is a general-purpose programming language built using a modern approach to safety, performance, and software design patterns.
Author: Steven Van Impe &lt;steven.vanimpe@icloud.com&gt;
Contributors: Chris Eidhof &lt;chris@eidhof.nl&gt;, Nate Cook &lt;natecook@gmail.com&gt;, Alexander Lichter &lt;manniL@gmx.net&gt;, Richard Gibson &lt;gibson042@github&gt;
Website: https://swift.org
Category: common, system
*/

/** @type LanguageFn */
function swift(hljs) {
  const WHITESPACE = {
    match: /\s+/,
    relevance: 0
  };
  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#ID411
  const BLOCK_COMMENT = hljs.COMMENT(
    &#039;/\\*&#039;,
    &#039;\\*/&#039;,
    {
      contains: [ &#039;self&#039; ]
    }
  );
  const COMMENTS = [
    hljs.C_LINE_COMMENT_MODE,
    BLOCK_COMMENT
  ];

  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#ID413
  // https://docs.swift.org/swift-book/ReferenceManual/zzSummaryOfTheGrammar.html
  const DOT_KEYWORD = {
    match: [
      /\./,
      either(...dotKeywords, ...optionalDotKeywords)
    ],
    className: {
      2: &quot;keyword&quot;
    }
  };
  const KEYWORD_GUARD = {
    // Consume .keyword to prevent highlighting properties and methods as keywords.
    match: concat(/\./, either(...keywords)),
    relevance: 0
  };
  const PLAIN_KEYWORDS = keywords
    .filter(kw =&gt; typeof kw === &#039;string&#039;)
    .concat([ &quot;_|0&quot; ]); // seems common, so 0 relevance
  const REGEX_KEYWORDS = keywords
    .filter(kw =&gt; typeof kw !== &#039;string&#039;) // find regex
    .concat(keywordTypes)
    .map(keywordWrapper);
  const KEYWORD = {
    variants: [
      {
        className: &#039;keyword&#039;,
        match: either(...REGEX_KEYWORDS, ...optionalDotKeywords)
      }
    ]
  };
  // find all the regular keywords
  const KEYWORDS = {
    $pattern: either(
      /\b\w+/, // regular keywords
      /#\w+/ // number keywords
    ),
    keyword: PLAIN_KEYWORDS
      .concat(numberSignKeywords),
    literal: literals
  };
  const KEYWORD_MODES = [
    DOT_KEYWORD,
    KEYWORD_GUARD,
    KEYWORD
  ];

  // https://github.com/apple/swift/tree/main/stdlib/public/core
  const BUILT_IN_GUARD = {
    // Consume .built_in to prevent highlighting properties and methods.
    match: concat(/\./, either(...builtIns)),
    relevance: 0
  };
  const BUILT_IN = {
    className: &#039;built_in&#039;,
    match: concat(/\b/, either(...builtIns), /(?=\()/)
  };
  const BUILT_INS = [
    BUILT_IN_GUARD,
    BUILT_IN
  ];

  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#ID418
  const OPERATOR_GUARD = {
    // Prevent -&gt; from being highlighting as an operator.
    match: /-&gt;/,
    relevance: 0
  };
  const OPERATOR = {
    className: &#039;operator&#039;,
    relevance: 0,
    variants: [
      {
        match: operator
      },
      {
        // dot-operator: only operators that start with a dot are allowed to use dots as
        // characters (..., ...&lt;, .*, etc). So there rule here is: a dot followed by one or more
        // characters that may also include dots.
        match: `\\.(\\.|${operatorCharacter})+`
      }
    ]
  };
  const OPERATORS = [
    OPERATOR_GUARD,
    OPERATOR
  ];

  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#grammar_numeric-literal
  // TODO: Update for leading `-` after lookbehind is supported everywhere
  const decimalDigits = &#039;([0-9]_*)+&#039;;
  const hexDigits = &#039;([0-9a-fA-F]_*)+&#039;;
  const NUMBER = {
    className: &#039;number&#039;,
    relevance: 0,
    variants: [
      // decimal floating-point-literal (subsumes decimal-literal)
      {
        match: `\\b(${decimalDigits})(\\.(${decimalDigits}))?` + `([eE][+-]?(${decimalDigits}))?\\b`
      },
      // hexadecimal floating-point-literal (subsumes hexadecimal-literal)
      {
        match: `\\b0x(${hexDigits})(\\.(${hexDigits}))?` + `([pP][+-]?(${decimalDigits}))?\\b`
      },
      // octal-literal
      {
        match: /\b0o([0-7]_*)+\b/
      },
      // binary-literal
      {
        match: /\b0b([01]_*)+\b/
      }
    ]
  };

  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#grammar_string-literal
  const ESCAPED_CHARACTER = (rawDelimiter = &quot;&quot;) =&gt; ({
    className: &#039;subst&#039;,
    variants: [
      {
        match: concat(/\\/, rawDelimiter, /[0\\tnr&quot;&#039;]/)
      },
      {
        match: concat(/\\/, rawDelimiter, /u\{[0-9a-fA-F]{1,8}\}/)
      }
    ]
  });
  const ESCAPED_NEWLINE = (rawDelimiter = &quot;&quot;) =&gt; ({
    className: &#039;subst&#039;,
    match: concat(/\\/, rawDelimiter, /[\t ]*(?:[\r\n]|\r\n)/)
  });
  const INTERPOLATION = (rawDelimiter = &quot;&quot;) =&gt; ({
    className: &#039;subst&#039;,
    label: &quot;interpol&quot;,
    begin: concat(/\\/, rawDelimiter, /\(/),
    end: /\)/
  });
  const MULTILINE_STRING = (rawDelimiter = &quot;&quot;) =&gt; ({
    begin: concat(rawDelimiter, /&quot;&quot;&quot;/),
    end: concat(/&quot;&quot;&quot;/, rawDelimiter),
    contains: [
      ESCAPED_CHARACTER(rawDelimiter),
      ESCAPED_NEWLINE(rawDelimiter),
      INTERPOLATION(rawDelimiter)
    ]
  });
  const SINGLE_LINE_STRING = (rawDelimiter = &quot;&quot;) =&gt; ({
    begin: concat(rawDelimiter, /&quot;/),
    end: concat(/&quot;/, rawDelimiter),
    contains: [
      ESCAPED_CHARACTER(rawDelimiter),
      INTERPOLATION(rawDelimiter)
    ]
  });
  const STRING = {
    className: &#039;string&#039;,
    variants: [
      MULTILINE_STRING(),
      MULTILINE_STRING(&quot;#&quot;),
      MULTILINE_STRING(&quot;##&quot;),
      MULTILINE_STRING(&quot;###&quot;),
      SINGLE_LINE_STRING(),
      SINGLE_LINE_STRING(&quot;#&quot;),
      SINGLE_LINE_STRING(&quot;##&quot;),
      SINGLE_LINE_STRING(&quot;###&quot;)
    ]
  };

  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#ID412
  const QUOTED_IDENTIFIER = {
    match: concat(/`/, identifier, /`/)
  };
  const IMPLICIT_PARAMETER = {
    className: &#039;variable&#039;,
    match: /\$\d+/
  };
  const PROPERTY_WRAPPER_PROJECTION = {
    className: &#039;variable&#039;,
    match: `\\$${identifierCharacter}+`
  };
  const IDENTIFIERS = [
    QUOTED_IDENTIFIER,
    IMPLICIT_PARAMETER,
    PROPERTY_WRAPPER_PROJECTION
  ];

  // https://docs.swift.org/swift-book/ReferenceManual/Attributes.html
  const AVAILABLE_ATTRIBUTE = {
    match: /(@|#(un)?)available/,
    className: &quot;keyword&quot;,
    starts: {
      contains: [
        {
          begin: /\(/,
          end: /\)/,
          keywords: availabilityKeywords,
          contains: [
            ...OPERATORS,
            NUMBER,
            STRING
          ]
        }
      ]
    }
  };
  const KEYWORD_ATTRIBUTE = {
    className: &#039;keyword&#039;,
    match: concat(/@/, either(...keywordAttributes))
  };
  const USER_DEFINED_ATTRIBUTE = {
    className: &#039;meta&#039;,
    match: concat(/@/, identifier)
  };
  const ATTRIBUTES = [
    AVAILABLE_ATTRIBUTE,
    KEYWORD_ATTRIBUTE,
    USER_DEFINED_ATTRIBUTE
  ];

  // https://docs.swift.org/swift-book/ReferenceManual/Types.html
  const TYPE = {
    match: lookahead(/\b[A-Z]/),
    relevance: 0,
    contains: [
      { // Common Apple frameworks, for relevance boost
        className: &#039;type&#039;,
        match: concat(/(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)/, identifierCharacter, &#039;+&#039;)
      },
      { // Type identifier
        className: &#039;type&#039;,
        match: typeIdentifier,
        relevance: 0
      },
      { // Optional type
        match: /[?!]+/,
        relevance: 0
      },
      { // Variadic parameter
        match: /\.\.\./,
        relevance: 0
      },
      { // Protocol composition
        match: concat(/\s+&amp;\s+/, lookahead(typeIdentifier)),
        relevance: 0
      }
    ]
  };
  const GENERIC_ARGUMENTS = {
    begin: /&lt;/,
    end: /&gt;/,
    keywords: KEYWORDS,
    contains: [
      ...COMMENTS,
      ...KEYWORD_MODES,
      ...ATTRIBUTES,
      OPERATOR_GUARD,
      TYPE
    ]
  };
  TYPE.contains.push(GENERIC_ARGUMENTS);

  // https://docs.swift.org/swift-book/ReferenceManual/Expressions.html#ID552
  // Prevents element names from being highlighted as keywords.
  const TUPLE_ELEMENT_NAME = {
    match: concat(identifier, /\s*:/),
    keywords: &quot;_|0&quot;,
    relevance: 0
  };
  // Matches tuples as well as the parameter list of a function type.
  const TUPLE = {
    begin: /\(/,
    end: /\)/,
    relevance: 0,
    keywords: KEYWORDS,
    contains: [
      &#039;self&#039;,
      TUPLE_ELEMENT_NAME,
      ...COMMENTS,
      ...KEYWORD_MODES,
      ...BUILT_INS,
      ...OPERATORS,
      NUMBER,
      STRING,
      ...IDENTIFIERS,
      ...ATTRIBUTES,
      TYPE
    ]
  };

  const GENERIC_PARAMETERS = {
    begin: /&lt;/,
    end: /&gt;/,
    contains: [
      ...COMMENTS,
      TYPE
    ]
  };
  const FUNCTION_PARAMETER_NAME = {
    begin: either(
      lookahead(concat(identifier, /\s*:/)),
      lookahead(concat(identifier, /\s+/, identifier, /\s*:/))
    ),
    end: /:/,
    relevance: 0,
    contains: [
      {
        className: &#039;keyword&#039;,
        match: /\b_\b/
      },
      {
        className: &#039;params&#039;,
        match: identifier
      }
    ]
  };
  const FUNCTION_PARAMETERS = {
    begin: /\(/,
    end: /\)/,
    keywords: KEYWORDS,
    contains: [
      FUNCTION_PARAMETER_NAME,
      ...COMMENTS,
      ...KEYWORD_MODES,
      ...OPERATORS,
      NUMBER,
      STRING,
      ...ATTRIBUTES,
      TYPE,
      TUPLE
    ],
    endsParent: true,
    illegal: /[&quot;&#039;]/
  };
  // https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID362
  const FUNCTION = {
    match: [
      /func/,
      /\s+/,
      either(QUOTED_IDENTIFIER.match, identifier, operator)
    ],
    className: {
      1: &quot;keyword&quot;,
      3: &quot;title.function&quot;
    },
    contains: [
      GENERIC_PARAMETERS,
      FUNCTION_PARAMETERS,
      WHITESPACE
    ],
    illegal: [
      /\[/,
      /%/
    ]
  };

  // https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID375
  // https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID379
  const INIT_SUBSCRIPT = {
    match: [
      /\b(?:subscript|init[?!]?)/,
      /\s*(?=[&lt;(])/,
    ],
    className: {
      1: &quot;keyword&quot;
    },
    contains: [
      GENERIC_PARAMETERS,
      FUNCTION_PARAMETERS,
      WHITESPACE
    ],
    illegal: /\[|%/
  };
  // https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID380
  const OPERATOR_DECLARATION = {
    match: [
      /operator/,
      /\s+/,
      operator
    ],
    className: {
      1: &quot;keyword&quot;,
      3: &quot;title&quot;
    }
  };

  // https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID550
  const PRECEDENCEGROUP = {
    begin: [
      /precedencegroup/,
      /\s+/,
      typeIdentifier
    ],
    className: {
      1: &quot;keyword&quot;,
      3: &quot;title&quot;
    },
    contains: [ TYPE ],
    keywords: [
      ...precedencegroupKeywords,
      ...literals
    ],
    end: /}/
  };

  // Add supported submodes to string interpolation.
  for (const variant of STRING.variants) {
    const interpolation = variant.contains.find(mode =&gt; mode.label === &quot;interpol&quot;);
    // TODO: Interpolation can contain any expression, so there&#039;s room for improvement here.
    interpolation.keywords = KEYWORDS;
    const submodes = [
      ...KEYWORD_MODES,
      ...BUILT_INS,
      ...OPERATORS,
      NUMBER,
      STRING,
      ...IDENTIFIERS
    ];
    interpolation.contains = [
      ...submodes,
      {
        begin: /\(/,
        end: /\)/,
        contains: [
          &#039;self&#039;,
          ...submodes
        ]
      }
    ];
  }

  return {
    name: &#039;Swift&#039;,
    keywords: KEYWORDS,
    contains: [
      ...COMMENTS,
      FUNCTION,
      INIT_SUBSCRIPT,
      {
        beginKeywords: &#039;struct protocol class extension enum actor&#039;,
        end: &#039;\\{&#039;,
        excludeEnd: true,
        keywords: KEYWORDS,
        contains: [
          hljs.inherit(hljs.TITLE_MODE, {
            className: &quot;title.class&quot;,
            begin: /[A-Za-z$_][\u00C0-\u02B80-9A-Za-z$_]*/
          }),
          ...KEYWORD_MODES
        ]
      },
      OPERATOR_DECLARATION,
      PRECEDENCEGROUP,
      {
        beginKeywords: &#039;import&#039;,
        end: /$/,
        contains: [ ...COMMENTS ],
        relevance: 0
      },
      ...KEYWORD_MODES,
      ...BUILT_INS,
      ...OPERATORS,
      NUMBER,
      STRING,
      ...IDENTIFIERS,
      ...ATTRIBUTES,
      TYPE,
      TUPLE
    ]
  };
}

module.exports = swift;</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
