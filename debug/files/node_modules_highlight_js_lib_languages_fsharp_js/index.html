<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/highlight.js/lib/languages/fsharp.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/highlight.js/lib/languages/fsharp.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">57.40</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">626</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">22.39</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">2.55</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/**
 * @param {string} value
 * @returns {RegExp}
 * */
function escape(value) {
  return new RegExp(value.replace(/[-/\\^$*+?.()|[\]{}]/g, &#039;\\$&amp;&#039;), &#039;m&#039;);
}

/**
 * @param {RegExp | string } re
 * @returns {string}
 */
function source(re) {
  if (!re) return null;
  if (typeof re === &quot;string&quot;) return re;

  return re.source;
}

/**
 * @param {RegExp | string } re
 * @returns {string}
 */
function lookahead(re) {
  return concat(&#039;(?=&#039;, re, &#039;)&#039;);
}

/**
 * @param {...(RegExp | string) } args
 * @returns {string}
 */
function concat(...args) {
  const joined = args.map((x) =&gt; source(x)).join(&quot;&quot;);
  return joined;
}

/**
 * @param { Array&lt;string | RegExp | Object&gt; } args
 * @returns {object}
 */
function stripOptionsFromArgs(args) {
  const opts = args[args.length - 1];

  if (typeof opts === &#039;object&#039; &amp;&amp; opts.constructor === Object) {
    args.splice(args.length - 1, 1);
    return opts;
  } else {
    return {};
  }
}

/** @typedef { {capture?: boolean} } RegexEitherOptions */

/**
 * Any of the passed expresssions may match
 *
 * Creates a huge this | this | that | that match
 * @param {(RegExp | string)[] | [...(RegExp | string)[], RegexEitherOptions]} args
 * @returns {string}
 */
function either(...args) {
  /** @type { object &amp; {capture?: boolean} }  */
  const opts = stripOptionsFromArgs(args);
  const joined = &#039;(&#039;
    + (opts.capture ? &quot;&quot; : &quot;?:&quot;)
    + args.map((x) =&gt; source(x)).join(&quot;|&quot;) + &quot;)&quot;;
  return joined;
}

/*
Language: F#
Author: Jonas Follesø &lt;jonas@follesoe.no&gt;
Contributors: Troy Kershaw &lt;hello@troykershaw.com&gt;, Henrik Feldt &lt;henrik@haf.se&gt;, Melvyn Laïly &lt;melvyn.laily@gmail.com&gt;
Website: https://docs.microsoft.com/en-us/dotnet/fsharp/
Category: functional
*/

/** @type LanguageFn */
function fsharp(hljs) {
  const KEYWORDS = [
    &quot;abstract&quot;,
    &quot;and&quot;,
    &quot;as&quot;,
    &quot;assert&quot;,
    &quot;base&quot;,
    &quot;begin&quot;,
    &quot;class&quot;,
    &quot;default&quot;,
    &quot;delegate&quot;,
    &quot;do&quot;,
    &quot;done&quot;,
    &quot;downcast&quot;,
    &quot;downto&quot;,
    &quot;elif&quot;,
    &quot;else&quot;,
    &quot;end&quot;,
    &quot;exception&quot;,
    &quot;extern&quot;,
    // &quot;false&quot;, // literal
    &quot;finally&quot;,
    &quot;fixed&quot;,
    &quot;for&quot;,
    &quot;fun&quot;,
    &quot;function&quot;,
    &quot;global&quot;,
    &quot;if&quot;,
    &quot;in&quot;,
    &quot;inherit&quot;,
    &quot;inline&quot;,
    &quot;interface&quot;,
    &quot;internal&quot;,
    &quot;lazy&quot;,
    &quot;let&quot;,
    &quot;match&quot;,
    &quot;member&quot;,
    &quot;module&quot;,
    &quot;mutable&quot;,
    &quot;namespace&quot;,
    &quot;new&quot;,
    // &quot;not&quot;, // built_in
    // &quot;null&quot;, // literal
    &quot;of&quot;,
    &quot;open&quot;,
    &quot;or&quot;,
    &quot;override&quot;,
    &quot;private&quot;,
    &quot;public&quot;,
    &quot;rec&quot;,
    &quot;return&quot;,
    &quot;static&quot;,
    &quot;struct&quot;,
    &quot;then&quot;,
    &quot;to&quot;,
    // &quot;true&quot;, // literal
    &quot;try&quot;,
    &quot;type&quot;,
    &quot;upcast&quot;,
    &quot;use&quot;,
    &quot;val&quot;,
    &quot;void&quot;,
    &quot;when&quot;,
    &quot;while&quot;,
    &quot;with&quot;,
    &quot;yield&quot;
  ];

  const BANG_KEYWORD_MODE = {
    // monad builder keywords (matches before non-bang keywords)
    scope: &#039;keyword&#039;,
    match: /\b(yield|return|let|do|match|use)!/
  };

  const PREPROCESSOR_KEYWORDS = [
    &quot;if&quot;,
    &quot;else&quot;,
    &quot;endif&quot;,
    &quot;line&quot;,
    &quot;nowarn&quot;,
    &quot;light&quot;,
    &quot;r&quot;,
    &quot;i&quot;,
    &quot;I&quot;,
    &quot;load&quot;,
    &quot;time&quot;,
    &quot;help&quot;,
    &quot;quit&quot;
  ];

  const LITERALS = [
    &quot;true&quot;,
    &quot;false&quot;,
    &quot;null&quot;,
    &quot;Some&quot;,
    &quot;None&quot;,
    &quot;Ok&quot;,
    &quot;Error&quot;,
    &quot;infinity&quot;,
    &quot;infinityf&quot;,
    &quot;nan&quot;,
    &quot;nanf&quot;
  ];

  const SPECIAL_IDENTIFIERS = [
    &quot;__LINE__&quot;,
    &quot;__SOURCE_DIRECTORY__&quot;,
    &quot;__SOURCE_FILE__&quot;
  ];

  // Since it&#039;s possible to re-bind/shadow names (e.g. let char = &#039;c&#039;),
  // these builtin types should only be matched when a type name is expected.
  const KNOWN_TYPES = [
    // basic types
    &quot;bool&quot;,
    &quot;byte&quot;,
    &quot;sbyte&quot;,
    &quot;int8&quot;,
    &quot;int16&quot;,
    &quot;int32&quot;,
    &quot;uint8&quot;,
    &quot;uint16&quot;,
    &quot;uint32&quot;,
    &quot;int&quot;,
    &quot;uint&quot;,
    &quot;int64&quot;,
    &quot;uint64&quot;,
    &quot;nativeint&quot;,
    &quot;unativeint&quot;,
    &quot;decimal&quot;,
    &quot;float&quot;,
    &quot;double&quot;,
    &quot;float32&quot;,
    &quot;single&quot;,
    &quot;char&quot;,
    &quot;string&quot;,
    &quot;unit&quot;,
    &quot;bigint&quot;,
    // other native types or lowercase aliases
    &quot;option&quot;,
    &quot;voption&quot;,
    &quot;list&quot;,
    &quot;array&quot;,
    &quot;seq&quot;,
    &quot;byref&quot;,
    &quot;exn&quot;,
    &quot;inref&quot;,
    &quot;nativeptr&quot;,
    &quot;obj&quot;,
    &quot;outref&quot;,
    &quot;voidptr&quot;,
    // other important FSharp types
    &quot;Result&quot;
  ];

  const BUILTINS = [
    // Somewhat arbitrary list of builtin functions and values.
    // Most of them are declared in Microsoft.FSharp.Core
    // I tried to stay relevant by adding only the most idiomatic
    // and most used symbols that are not already declared as types.
    &quot;not&quot;,
    &quot;ref&quot;,
    &quot;raise&quot;,
    &quot;reraise&quot;,
    &quot;dict&quot;,
    &quot;readOnlyDict&quot;,
    &quot;set&quot;,
    &quot;get&quot;,
    &quot;enum&quot;,
    &quot;sizeof&quot;,
    &quot;typeof&quot;,
    &quot;typedefof&quot;,
    &quot;nameof&quot;,
    &quot;nullArg&quot;,
    &quot;invalidArg&quot;,
    &quot;invalidOp&quot;,
    &quot;id&quot;,
    &quot;fst&quot;,
    &quot;snd&quot;,
    &quot;ignore&quot;,
    &quot;lock&quot;,
    &quot;using&quot;,
    &quot;box&quot;,
    &quot;unbox&quot;,
    &quot;tryUnbox&quot;,
    &quot;printf&quot;,
    &quot;printfn&quot;,
    &quot;sprintf&quot;,
    &quot;eprintf&quot;,
    &quot;eprintfn&quot;,
    &quot;fprintf&quot;,
    &quot;fprintfn&quot;,
    &quot;failwith&quot;,
    &quot;failwithf&quot;
  ];

  const ALL_KEYWORDS = {
    keyword: KEYWORDS,
    literal: LITERALS,
    built_in: BUILTINS,
    &#039;variable.constant&#039;: SPECIAL_IDENTIFIERS
  };

  // (* potentially multi-line Meta Language style comment *)
  const ML_COMMENT =
    hljs.COMMENT(/\(\*(?!\))/, /\*\)/, {
      contains: [&quot;self&quot;]
    });
  // Either a multi-line (* Meta Language style comment *) or a single line // C style comment.
  const COMMENT = {
    variants: [
      ML_COMMENT,
      hljs.C_LINE_COMMENT_MODE,
    ]
  };

  // Most identifiers can contain apostrophes
  const IDENTIFIER_RE = /[a-zA-Z_](\w|&#039;)*/;

  const QUOTED_IDENTIFIER = {
    scope: &#039;variable&#039;,
    begin: /``/,
    end: /``/
  };

  // &#039;a or ^a where a can be a ``quoted identifier``
  const BEGIN_GENERIC_TYPE_SYMBOL_RE = /\B(&#039;|\^)/;
  const GENERIC_TYPE_SYMBOL = {
    scope: &#039;symbol&#039;,
    variants: [
      // the type name is a quoted identifier:
      { match: concat(BEGIN_GENERIC_TYPE_SYMBOL_RE, /``.*?``/) },
      // the type name is a normal identifier (we don&#039;t use IDENTIFIER_RE because there cannot be another apostrophe here):
      { match: concat(BEGIN_GENERIC_TYPE_SYMBOL_RE, hljs.UNDERSCORE_IDENT_RE) }
    ],
    relevance: 0
  };

  const makeOperatorMode = function({ includeEqual }) {
    // List or symbolic operator characters from the FSharp Spec 4.1, minus the dot, and with `?` added, used for nullable operators.
    let allOperatorChars;
    if (includeEqual)
      allOperatorChars = &quot;!%&amp;*+-/&lt;=&gt;@^|~?&quot;;
    else
      allOperatorChars = &quot;!%&amp;*+-/&lt;&gt;@^|~?&quot;;
    const OPERATOR_CHARS = Array.from(allOperatorChars);
    const OPERATOR_CHAR_RE = concat(&#039;[&#039;, ...OPERATOR_CHARS.map(escape), &#039;]&#039;);
    // The lone dot operator is special. It cannot be redefined, and we don&#039;t want to highlight it. It can be used as part of a multi-chars operator though.
    const OPERATOR_CHAR_OR_DOT_RE = either(OPERATOR_CHAR_RE, /\./);
    // When a dot is present, it must be followed by another operator char:
    const OPERATOR_FIRST_CHAR_OF_MULTIPLE_RE = concat(OPERATOR_CHAR_OR_DOT_RE, lookahead(OPERATOR_CHAR_OR_DOT_RE));
    const SYMBOLIC_OPERATOR_RE = either(
      concat(OPERATOR_FIRST_CHAR_OF_MULTIPLE_RE, OPERATOR_CHAR_OR_DOT_RE, &#039;*&#039;), // Matches at least 2 chars operators
      concat(OPERATOR_CHAR_RE, &#039;+&#039;), // Matches at least one char operators
    );
    return {
      scope: &#039;operator&#039;,
      match: either(
        // symbolic operators:
        SYMBOLIC_OPERATOR_RE,
        // other symbolic keywords:
        // Type casting and conversion operators:
        /:\?&gt;/,
        /:\?/,
        /:&gt;/,
        /:=/, // Reference cell assignment
        /::?/, // : or ::
        /\$/), // A single $ can be used as an operator
      relevance: 0
    };
  };

  const OPERATOR = makeOperatorMode({ includeEqual: true });
  // This variant is used when matching &#039;=&#039; should end a parent mode:
  const OPERATOR_WITHOUT_EQUAL = makeOperatorMode({ includeEqual: false });

  const makeTypeAnnotationMode = function(prefix, prefixScope) {
    return {
      begin: concat( // a type annotation is a
        prefix,            // should be a colon or the &#039;of&#039; keyword
        lookahead(   // that has to be followed by
          concat(
            /\s*/,         // optional space
            either(  // then either of:
              /\w/,        // word
              /&#039;/,         // generic type name
              /\^/,        // generic type name
              /#/,         // flexible type name
              /``/,        // quoted type name
              /\(/,        // parens type expression
              /{\|/,       // anonymous type annotation
      )))),
      beginScope: prefixScope,
      // BUG: because ending with \n is necessary for some cases, multi-line type annotations are not properly supported.
      // Examples where \n is required at the end:
      // - abstract member definitions in classes: abstract Property : int * string
      // - return type annotations: let f f&#039; = f&#039; () : returnTypeAnnotation
      // - record fields definitions: { A : int \n B : string }
      end: lookahead(
        either(
          /\n/,
          /=/)),
      relevance: 0,
      // we need the known types, and we need the type constraint keywords and literals. e.g.: when &#039;a : null
      keywords: hljs.inherit(ALL_KEYWORDS, { type: KNOWN_TYPES }),
      contains: [
        COMMENT,
        GENERIC_TYPE_SYMBOL,
        hljs.inherit(QUOTED_IDENTIFIER, { scope: null }), // match to avoid strange patterns inside that may break the parsing
        OPERATOR_WITHOUT_EQUAL
      ]
    };
  };

  const TYPE_ANNOTATION = makeTypeAnnotationMode(/:/, &#039;operator&#039;);
  const DISCRIMINATED_UNION_TYPE_ANNOTATION = makeTypeAnnotationMode(/\bof\b/, &#039;keyword&#039;);

  // type MyType&lt;&#039;a&gt; = ...
  const TYPE_DECLARATION = {
    begin: [
      /(^|\s+)/, // prevents matching the following: `match s.stype with`
      /type/,
      /\s+/,
      IDENTIFIER_RE
    ],
    beginScope: {
      2: &#039;keyword&#039;,
      4: &#039;title.class&#039;
    },
    end: lookahead(/\(|=|$/),
    keywords: ALL_KEYWORDS, // match keywords in type constraints. e.g.: when &#039;a : null
    contains: [
      COMMENT,
      hljs.inherit(QUOTED_IDENTIFIER, { scope: null }), // match to avoid strange patterns inside that may break the parsing
      GENERIC_TYPE_SYMBOL,
      {
        // For visual consistency, highlight type brackets as operators.
        scope: &#039;operator&#039;,
        match: /&lt;|&gt;/
      },
      TYPE_ANNOTATION // generic types can have constraints, which are type annotations. e.g. type MyType&lt;&#039;T when &#039;T : delegate&lt;obj * string&gt;&gt; =
    ]
  };

  const COMPUTATION_EXPRESSION = {
    // computation expressions:
    scope: &#039;computation-expression&#039;,
    // BUG: might conflict with record deconstruction. e.g. let f { Name = name } = name // will highlight f
    match: /\b[_a-z]\w*(?=\s*\{)/
  };

  const PREPROCESSOR = {
    // preprocessor directives and fsi commands:
    begin: [
      /^\s*/,
      concat(/#/, either(...PREPROCESSOR_KEYWORDS)),
      /\b/
    ],
    beginScope: { 2: &#039;meta&#039; },
    end: lookahead(/\s|$/)
  };

  // TODO: this definition is missing support for type suffixes and octal notation.
  // BUG: range operator without any space is wrongly interpreted as a single number (e.g. 1..10 )
  const NUMBER = {
    variants: [
      hljs.BINARY_NUMBER_MODE,
      hljs.C_NUMBER_MODE
    ]
  };

  // All the following string definitions are potentially multi-line.
  // BUG: these definitions are missing support for byte strings (suffixed with B)

  // &quot;...&quot;
  const QUOTED_STRING = {
    scope: &#039;string&#039;,
    begin: /&quot;/,
    end: /&quot;/,
    contains: [
      hljs.BACKSLASH_ESCAPE
    ]
  };
  // @&quot;...&quot;
  const VERBATIM_STRING = {
    scope: &#039;string&#039;,
    begin: /@&quot;/,
    end: /&quot;/,
    contains: [
      {
        match: /&quot;&quot;/ // escaped &quot;
      },
      hljs.BACKSLASH_ESCAPE
    ]
  };
  // &quot;&quot;&quot;...&quot;&quot;&quot;
  const TRIPLE_QUOTED_STRING = {
    scope: &#039;string&#039;,
    begin: /&quot;&quot;&quot;/,
    end: /&quot;&quot;&quot;/,
    relevance: 2
  };
  const SUBST = {
    scope: &#039;subst&#039;,
    begin: /\{/,
    end: /\}/,
    keywords: ALL_KEYWORDS
  };
  // $&quot;...{1+1}...&quot;
  const INTERPOLATED_STRING = {
    scope: &#039;string&#039;,
    begin: /\$&quot;/,
    end: /&quot;/,
    contains: [
      {
        match: /\{\{/ // escaped {
      },
      {
        match: /\}\}/ // escaped }
      },
      hljs.BACKSLASH_ESCAPE,
      SUBST
    ]
  };
  // $@&quot;...{1+1}...&quot;
  const INTERPOLATED_VERBATIM_STRING = {
    scope: &#039;string&#039;,
    begin: /(\$@|@\$)&quot;/,
    end: /&quot;/,
    contains: [
      {
        match: /\{\{/ // escaped {
      },
      {
        match: /\}\}/ // escaped }
      },
      {
        match: /&quot;&quot;/
      },
      hljs.BACKSLASH_ESCAPE,
      SUBST
    ]
  };
  // $&quot;&quot;&quot;...{1+1}...&quot;&quot;&quot;
  const INTERPOLATED_TRIPLE_QUOTED_STRING = {
    scope: &#039;string&#039;,
    begin: /\$&quot;&quot;&quot;/,
    end: /&quot;&quot;&quot;/,
    contains: [
      {
        match: /\{\{/ // escaped {
      },
      {
        match: /\}\}/ // escaped }
      },
      SUBST
    ],
    relevance: 2
  };
  // &#039;.&#039;
  const CHAR_LITERAL = {
    scope: &#039;string&#039;,
    match: concat(
      /&#039;/,
      either(
        /[^\\&#039;]/, // either a single non escaped char...
        /\\(?:.|\d{3}|x[a-fA-F\d]{2}|u[a-fA-F\d]{4}|U[a-fA-F\d]{8})/ // ...or an escape sequence
      ),
      /&#039;/
    )
  };
  // F# allows a lot of things inside string placeholders.
  // Things that don&#039;t currently seem allowed by the compiler: types definition, attributes usage.
  // (Strictly speaking, some of the followings are only allowed inside triple quoted interpolated strings...)
  SUBST.contains = [
    INTERPOLATED_VERBATIM_STRING,
    INTERPOLATED_STRING,
    VERBATIM_STRING,
    QUOTED_STRING,
    CHAR_LITERAL,
    BANG_KEYWORD_MODE,
    COMMENT,
    QUOTED_IDENTIFIER,
    TYPE_ANNOTATION,
    COMPUTATION_EXPRESSION,
    PREPROCESSOR,
    NUMBER,
    GENERIC_TYPE_SYMBOL,
    OPERATOR
  ];
  const STRING = {
    variants: [
      INTERPOLATED_TRIPLE_QUOTED_STRING,
      INTERPOLATED_VERBATIM_STRING,
      INTERPOLATED_STRING,
      TRIPLE_QUOTED_STRING,
      VERBATIM_STRING,
      QUOTED_STRING,
      CHAR_LITERAL
    ]
  };

  return {
    name: &#039;F#&#039;,
    aliases: [
      &#039;fs&#039;,
      &#039;f#&#039;
    ],
    keywords: ALL_KEYWORDS,
    illegal: /\/\*/,
    classNameAliases: {
      &#039;computation-expression&#039;: &#039;keyword&#039;
    },
    contains: [
      BANG_KEYWORD_MODE,
      STRING,
      COMMENT,
      QUOTED_IDENTIFIER,
      TYPE_DECLARATION,
      {
        // e.g. [&lt;Attributes(&quot;&quot;)&gt;] or [&lt;``module``: MyCustomAttributeThatWorksOnModules&gt;]
        // or [&lt;Sealed; NoEquality; NoComparison; CompiledName(&quot;FSharpAsync`1&quot;)&gt;]
        scope: &#039;meta&#039;,
        begin: /\[&lt;/,
        end: /&gt;\]/,
        relevance: 2,
        contains: [
          QUOTED_IDENTIFIER,
          // can contain any constant value
          TRIPLE_QUOTED_STRING,
          VERBATIM_STRING,
          QUOTED_STRING,
          CHAR_LITERAL,
          NUMBER
        ]
      },
      DISCRIMINATED_UNION_TYPE_ANNOTATION,
      TYPE_ANNOTATION,
      COMPUTATION_EXPRESSION,
      PREPROCESSOR,
      NUMBER,
      GENERIC_TYPE_SYMBOL,
      OPERATOR
    ]
  };
}

module.exports = fsharp;</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
